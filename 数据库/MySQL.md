# MySQL 

1. Innodb
2. MyISAM



## 1. MySQL 存储引擎

### MyISAM 存储引擎

### ==不支持事务的存储引擎==.

是 MySQL5.5 之前的版本默认的存储引擎.是 MySQL 最早使用的存储引擎之一.

大部分 MySQL 的系统表和临时表默认的存储引擎.这里说的临时表说的是在排序,分组等操作后,当数据超过一定的大小后,由查询优化器简历的临时表.



#### 锁相关

- MyISAM 采用的是==表级锁==.

- MyISAM 在执行查询语句之前, 会自动给涉及的所有表添加读锁,

- 在执行更新操作(insert, update, delete)前, 会给所有设置的表添加写锁. 这个过程是自动的,不需要用户干预.

- 当一个线程获得一个表的写锁之后,只有持有锁的线程可以对表进行写操作,其他线程的读, 写操作都会等待, 直到释放锁.



MyISAM 会将表存储在系统文件中 : 一个数据文件(MYD 扩展名),一个索引文件(MYI 为扩展名), 这两个文件是 MyISAM 特有的文件.

另外还有一个用于记录表结构的文件(frm 为扩展名). 这个文件不是 MyISAM 特有的文件,MySQL 所有的存储引擎都会有这个文件.

#### 特性

1. 并发性与锁级别 : MyIASM 使用的是表级锁.而不是行级锁. 意味着对表中的数据进行修改时,需要对整张表加锁.读取数据时需要对所有的表加共享锁.所以使用 MyIASM 存储引擎的表,读取和写入这两种操作是互斥的.所以 MyISAM 对于读写混合操作的并发性并不是太好, 如果是只读的操作的话,并发性还是可以接受的. 因为共享锁并不会阻塞共享锁.
2. 表损坏修复 : MyISAM 支持对由于任意意外关闭而损坏的 MyISAM 表进行检查和修复. 这里说的修复并不是事务修复, 因为 MyISAM 并不是事务性的存储引擎, 所以不支持事务修复所需要的事务日志. 可以通过 check table tablename 对表进行检查, 如果正常. Msg_test 显示 OK, 使用 repair table tablename 进行恢复, 修复成功的话, Msg_text 显示 OK.
3. MyISAM 支持索引类型 : 全文索引, 前缀索引.
4. 支持压缩 (如果是只读表) : myisampack -b -f(强制压缩) xxx.MYI 进行压缩. xxx.OLD 是原来的没有压缩文件的备份. 对压缩的表只能进行读操作,不能进行写操作.

#### 使用 MyISAM 的限制 :

1. 版本再 MySQL5.0 之前的数据库,默认单表大小最大为 4 个 G.如果存储大表则需要修改 MAX_Rows 和 AVG_ROW_LENGTH 两个参数,相乘就是最后的最大大小.

2. 版本再 MySQL5.0 后的默认支持 256TB

   

#### MyISAM 适用的场景 : 

1. 非事务型应用. 因为 MyISAM 是一种不支持事务的存储引擎.
2. 只读类应用. 因为 MyISAM 支持对数据文件的压缩. 读取的时候会加共享锁,但是共享锁之前是不会阻塞的,所以对只读类应用还是比较好用的.
3. 空间类应用. 在 MySQL5.7 之前,MyISAM是唯一支持空间类数据的存储引擎,比如 GPS 信息啊什么的.







### Innodb

#### 支持事务的存储引擎.

MySQL5.58 版本之后,Innodb 代替 MyISAM 成为 MySQL 的默认存储引擎.

默认情况下采用的是行级锁, 也支持表级锁.





B): Innodb 使用==**表空间**==进行数据存储. 具体存储在什么表空间之中,由 innodb_file_per_table 参数决定. 

	如果 innodb_file_per_table 为 ON: 独立表空间. 为每个 Innodb 表创建一个以 tablename.ibd 为结尾的系统文件.
	
	如果 innodb_file_per_table 为 OFF : 系统表空间. ibdataX. X 代表从 1 开始的一个数字.
	
	可在终端中进入数据库 : mysql -uroot -proot.
	
	进入数据库 : use database_name;
	
	查看用的什么表空间 : show variables like ‘innodb_file_per_table’;
	
	默认是 NO, 针对所有的表.
	
	如果想关闭, 则 : set global innodb_file_per_table=off;





Innodb 也有两个系统文件 : 

如果 innodb_file_per_table 为 NO, 则有两个系统文件: 一个 tablename.frm 文件(存储表结构), 一个 tablename.ibd 文件(innodb 表实际存储的地方);

如果 innodb_file_per_table 为 OFF, 则只有一个系统文件 : 一个 tablename.frm 文件. 表存储在了ibdata1(ibdataX) 中.





C): 系统表空间和独立表空间要如何选择 : 即 innodb_file_per_table 这个参数要怎么设置?

表空间收缩方面 : 

1. 系统表空间无法简单的收缩文件大小 : 在 MySQL5.6 之前, innodb_file_per_table 的默认值是 OFF,即这 5.6 版本之前的表都存在系统表空间中, 所以系统表空间在不断的增长. 在磁盘空间不足的时候,我们需要删除长时间不用的数据文件. 比如以复制的方式备份数据库, 此时需要删除数据, 但是删除后,系统表空间文件的大小并不会改变.那就意味着会浪费很大的空间.
2. 独立表空间可以通过 optimize table 命令收缩系统文件. 如果对一个大表的数据进行清理之后,可以只对这一个表进行optimize tabel 收缩操作,虽然这样也会对这个表进行重建,但是相对于整个重建,要方便的多,而且不用重启服务器.





通过设置 `innodb_file_per_table = OFF` 是收缩系统表空间的唯一方法 : 

将这个数据库中的 Innodb 表导出后,删除所有的 innodb 表空间文件, 再重启 MySQL, 进行表空间的重建, 再导入数据.(复杂, 耗时).



IO 方面 : 

系统表空间会产生 IO 瓶颈. 因为只有一个文件,所以对多个表进行刷新时, 实际上是顺序进行的,所以会产生一定的 IO 瓶颈.

独立表空间可以同时向多个文件刷新数据.

所以对于频繁写操作的系统来说,比较适合使用独立表空间的方式.

所以, 对 Innodb 需要使用独立表空间. 即 innodb_file_er_table=NO



D): 将原来的系统表空间中的表转移到独立表空间中的方法 : 4 个步骤

1. 使用 mysqldump 导出所有数据库表数据.
2. 停止 MySQL 服务,修改参数(my.cnf配置文件),并加入innodb_file_per_table参数, 并删除原来的 Innodb 相关表空间文件.
3. 重启 MySQL 服务,并重建 Innodb 系统表空间.
4. 重新导入数据.

	







问题 : 

Innodb 是按照哪个索引的顺序来组织表的?

答案 : 主键

引出 : 所以每个 Innodb 表都必须有一个主键. 如果没有指定主键,那么 MySQL 就会优先的以表中的第一个非空唯一索引为主键. 如果也没有非空唯一索引的话,MySQL 就自动会生成一个 6 位字节的主键, 而这个主键的性能并不是最好的.



## 2. 索引

MySQL常见的索引有: Hash 索引, B-树索引, B+ 树索引, MySQL 默认使用的是 ==**B+树索引**==

