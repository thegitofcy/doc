# 设计模式概述



## 1. UML类图



## 2. 设计模式的分类

### 

设计模式可分为三类 : 创建型模式, 结构型模式, 行为型模式

1. 创建型模式: 是用来 **==创建对象的模式, 抽象了实例化的过程.帮助一个系统独立于其关联对象的创建, 组合和表示方式.==**
2. 结构性模式



### 2.1 创建型模式

创建型模式是用来 **==创建对象的模式, 抽象了实例化的过程.==**帮助一个系统独立于其关联对象的创建, 组合和表示方式.

所有创建型模式都有两个主要功能:

1. 将系统所使用的具体类的信息封装起来.
2. 隐藏类的实例是如何被创建和组织的. 外界对于这些对象只知道他们共同的接口, 而不清楚其具体的实现细节.



- 单例模式(Singleon)
  - 某个类只能生成一个实例, 该类提供了一个全局的访问点供外部获取该实例.
- 原型模式(Prototype)
  - 将一个对象作为原型, 通过对其进行复制而克隆出多个和原型类似的新实例.
- 工厂方法模式(FactoryMethod)
  - 定义一个用于创建产品的接口, 由子类决定生产什么产品.
- 抽象工程模式(AbstractFacoty)
  - 提供一个创建产品组的接口, 其每个子类可以生产一系列相关的产品.
- 建造者模式(Builder)
  - 讲一个负责对象分解成多个相对简单的部分, 然后根据不同需要分别创建它们, 最后构建成该复杂对象.

### 2.2 结构性模式

- 代理模式(Proxy)
  - 为某对象提供一种代理, 以控制对该对象的访问. 即客户端通过代理对象间接的访问该对象, 从而限制,增强或者修改对象的一些特征.
- 适配器模式(Adapter)
  - 将一个类的接口转换成客户希望的另外一个接口, 是的原本由于接口不兼容而不能在一起工作的那些类能在一起工作.
  - 简单的说假如有接口A和接口B, 创建一个中间转化类C, 通过C可以实现A和B在一起工作的目的.
- 桥接模式(Bridge)
  - 将抽象与现实抽离, 使他们可以独立变化. 它是用组合关系代替继承关系来实现的. 从而减低了抽象和实现这两个可变维度的耦合度.
- 装饰者模式(Decorator)
  - 在不改变类文件以及不适用继承的情况下,动态的给一个现有的对象增加一些职责, 使这些子系统更加容易被访问.
- 外观模式(Facade)
  - 为多个复杂的子系统提供一个一致的接口, 是这些子系统更加容易被访问.
- 享元模式(Flyweight)
  - 运用共享技术来有效地支持大量细粒度对象的复用.
- 组合模式(Composite)
  - 将对象组合成树桩层次结构, 使用户对单个对象和组合对象具有一致的访问性.



### 2.3. 行为型模式

行为型设计模式关注的是 **==对象的行为==**. 用来解决对象之间的联系问题.

- 模板方法模式(Template Method)
  - 定义一个操作中的算法骨架, 将算法的一些步骤延迟到子类中, 使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤.
- 策略模式(Strategy)
  - 定义了一系列的算法, 并将每个算法封装起来, 使它们可以相互替换, 且算法的改变不会影响使用算法的客户.
- 命令模式(Command)
  - 将一个请求封装为一个对象, 使发出请求的责任和执行请求的责任分开.
- 职责链模式(Chain of Responsibility)
  - 把请求从链中的一个对象传到下一个对象, 知道请求被响应为止. 通过这种方式除去对象之间的耦合.
- 状态模式(State)
  - 允许一个对象在其内部状态发生改变时改变其行为能力.
- 观察者模式(Observer)
  - 多个对象之间存在一对多关系, 当一个对象发生改变时,把这种改变通知给其他多个对象, 从而影响其他对象的行为.
- 中介者模式(Mediator)
  - 定义一个中介对象来简化原有对象之间的交互关系, 降低系统中对象间的耦合度, 使原有对象之间不必相互了解.
- 迭代器模式(Iterator)
  - 提供一种方法来顺序访问聚合对象中的一些列数据, 而不暴露聚合对象的内部标识
- 访问者模式(Visitor)
  - 在不改变集合元素的前提下, 为一个集合中的每个元素提供多种访问方式, 即每个元素有多个访问者对象访问.
- 备忘录模式(Memento)
  - 在不破坏封装性的前提下, 获取并保存一个对象的内部状态, 以便以后恢复它.
- 解释器模式(Interpreter)
  - 提供如何定义语言的文法, 以及对语言橘子的解释方法, 即解释器.