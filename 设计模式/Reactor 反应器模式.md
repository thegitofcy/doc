# 1. Reactor 模式(反应器模式) 介绍

- 事件驱动, 回调函数
- 和观察者模式比较像. 观察者主要用于一对多的情况, 就是一个被观察者, 多个观察者. 事件驱动是多个事件源关联.



- NIO 就是基于事件驱动来的
- Netty 基于 Reactor 模式
- Nginx 基于 Reactor 模式
- Redis 基于 Reactor 模式

## 1. Reactor 模式简单理解

客人点菜: 假设每一个人来就餐就是一个 I/O 事件

- 多线程: 来一个人就餐, 就有一个服务员去服务, 来十个人就有 10 个服务员去服务, 来 1 万个客人就有 1 万个服务员去服务
- 线程池: 组成 10 个服务员的线程池, 一个服务员服务完一个人后就去服务下一个, 但是假如一个人点餐非常慢(读写文件, 网络请求等), 那其他人就要等很久.
- 事件驱动: 客人选好菜后, 才叫服务员过来服务,给服务员说: 我要宫保鸡丁, `做好后送到 14 桌`. 如果没有叫, 服务员就干其他的事. 其中 `做好后送到 14 桌` 就是回调函数.



### 1. 事件驱动

客人选好菜后, 才叫服务员过来服务,给服务员说: 我要宫保鸡丁, `做好后送到 14 桌`. 如果没有叫, 服务员就干其他的事.

简单点说就是: `等发生了事件, 再通知我, 我再去处理.`



# 2. Reactor 详解

Reactor 基于事件驱动(`等发生了事件, 再通知我, 我再去处理`).



==**关键点:**==

1. 事件驱动(Event Handling)

2. 可以处理一个或者多个输入源(one or more inputs)

3. 通过 server Handler 同步的将输入事件 (Event) 采用多路复用分发给相应的 Request Handler(多个)处理

   <img src="/Users/cy/develop/doc/local/picture/Reactor 模式/image-20200914143941541.png" alt="image-20200914143941541" style="zoom:50%;" />



==**Reactor 处理方式:**==



## 1. 分而治之

一个连接里完整的网络处理分为: accept, read, decode, process, encode, send 这几步.

Reactor 模式将每一步映射为一个 Task, 服务端线程执行最小的逻辑单元是 Task, 不再是一次完整的网络请求, 并且采用 `非阻塞方式执行`.



## 2. 事件驱动

每个 Task 对应特定网络事件, 当 Task 准备就绪的时候, Reactor 接收到相应的网络事件通知,并将 Task 分发给绑定了对应网络事件的 Handler 执行.



## 3. 几个角色

Reactor: 负责响应事件, 将事件分发给绑定了该事件的 Handler 处理.

Handler: 事件处理器. 绑定了某类事件, 负责执行对应事件的 Task事件进行处理.

Acceptor: Handler的一种, 绑定了 connect 事件, 当客户端发起 connect 请求时, Reactor 会将 accept 事件分发给 Acceptor 处理.