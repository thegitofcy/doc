# Dubbo

关键字: ==**长连接**==

## 1. Dubbo 简介

### 1.1 Dubbo 背景

==**架构演变图**==:

![image-20200603101822867](/Users/cy/develop/doc/local/picture/Dubbo/image-20200603101822867.png)

随着互联网发展, 网站应用越来越大, ==**单一应用结构**== 或者 ==**垂直应用架构**== 已经无法应对. ==**分布式架构**==和==**流式计算架构**==势在必行.

- ==**单一应用结构**== **==将所有的功能部署在一起, 以减少部署节点和成本==**, 此时用于 ==**简化增删改查的数据访问框架(ORM)是关键.**==

- ==**垂直应用结构**== 是在 ==**单一应用架构**==的基础上, 将**==应用拆分成互不相干的几个应用,以提升效率==**. 此时用于 ==**加速前端页面开发的 Web 框架(MVC)是关键.**==

- ==**分布式服务架构**== 当 ==垂直应用==越来越多, 应用间的交互不可避免, ==将核心业务抽取出来, 作为独立的服务.逐渐形成稳定的服务中心==. 此时, 用于 ==**提高业务复用及整合的分布式服务框架(RPC)是关键**==.
- ==**流式计算架构**== 当服务越来越多, 容量的评估, 小服务资源的浪费等问题逐渐显现, 此时 ==**需增加一个调度中心基于访问压力实时管理集群容量, 提高集群利用率. **==此时, 用于 ==**提高机器李永利的资源调度和治理中心(SOA)是关键.**==

  

### 1.2 Dubbo 需求

![image-20200603102327633](/Users/cy/develop/doc/local/picture/Dubbo/image-20200603102327633.png)

在大规模服务化之前, 应用只是通过 RMI 或者是 Hessian 等工具, 简单的暴露和引用远程服务, 通过配置服务的 URL 地址进行调用, 通过 F5等硬件进行负载均衡.

- ==当服务越来越多, 服务的 URL 配置管理变得非常困难, F5 硬负载的单点压力也越来越大==. 此时需要一个 ==服务注册中心==, 动态的注册和发现服务, 使服务的位置透明, 并通过在==消费方(Consumer)==获取==服务提供方(Provider)==地址列表,实现软负载, 降低对 F5 硬负载的依赖. 也能减少成本.
- 当进一步发展, 服务间依赖关系变得错综复杂, 甚至分不清哪个应用应该在哪个应用之前启动. 这是, 需要自动画出应用间的依赖关系图, 以供开发人员清理关系.
- 当服务的调用量越来越大, 服务的容量问题就暴露出来, 服务需要几个机器支撑? 什么时候改加机器? 为了解决这个问题, 第一步: 要将服务现在每天的调用量, 响应时间, 都统计出来, 作为容量规划的参考指标. 其次: 要可以动态调整权重, 在线上, 将某台机器的权重一直加大, 并在加大的过程中记录响应时间的变化, 知道响应时间达到阈值. 记录此时的访问量, 再以访问量乘以机器数反推总容量.

以上是 Dubbo 最基本的几个需求.



### 1.3 Dubbo 架构

![image-20200603103351977](/Users/cy/develop/doc/local/picture/Dubbo/image-20200603103351977.png)

==**节点说明:**==

- Provider: 服务提供者. 暴露服务
- Consumer: 服务消费者. 调用远程服务
- Registry: 注册中心. 服务注册与服务发现
- Monitor: 监控中心. 统计服务的调用次数和调用时间(先在内存中汇总, 然后每分钟一次发送到监控中心服务器, 并以报表展示)
- Container: 服务运行容器.



==**调用关系说明:**==

0. ==**Container**== 负责启动, 加载,运行 Provider
1. ==**Provider**== 在启动时, 向注册中心注册自己提供的服务.
2. ==**Consumer**== 在启动时, 向注册中心订阅自己需要的服务.获取到列表后, 会在本地缓存一份
3. ==**Register**== 返回 Provier 地址列表给 Consumer. 如果有变动, Register 则基于==**长连接**==推送变更数据到 Consumer.
4. Consumer 从 Provider 地址列表中,基于软负载均衡算法, 选一台 Provider 进行调用. 如果调用失败, 则再选一台调用.
5. Provider 和 Consumer 在内存中累计调用次数和调用时间, 定时每分钟发送一次统计数据到 Monitor.



==**Dubbo 架构特点:**==

==连通性, 健壮性, 伸缩性, 以及向未来架构的升级性.==



==**连通性:**==

- Register 负责服务地址的注册和查找, 相当于一个目录服务. Provider 和 Consumer 只在启动时和 Register 交互, Register 不转发请求, 压力较小.
- Monitor 负责统计各服务的调用次数和调用时间等. 统计先在内存进行汇总, 然后每分钟一次发送到监控中心服务器. 并以报表展示.
- Provider 向注册中心注册它提供的服务, 并汇报调用时间到监控中心, ==此时间不包含网络开销==.
- Consumer 从注册中心获取 Provider 地址列表. 并根据软负载均衡算法直接调用提供者. 同时汇报调用时间到监控中心. ==此时间包含网络开销.==
- Provider, Register, Consumer 三者间均为 ==**长连接**==. 监控中心除外.
- Register 基于==**长连接**==感知 Provider 的存在, 如果 Provider 宕机, Register 立即推送时间给 Consumer.
- Register 和 Monitor 都宕机, 不影响已运行的 Provider 和 Consumer. ==**Consumer在本地缓存了 Provider 地址列表.**==
- Register 和 Monitor 都是==**可选**==的, Consumer 可以直连 Provider.



==**健壮性:**==

- Monitor 宕机不影响使用, 只是丢失部分采样数据.
- 数据库宕机后, Register 仍能通过缓存提供 Provider 地址列表查询, 但是不能注册新服务.
- Register对等集群, 任意一台宕机后, 将自动切换到另一台.
- Register 全部宕机后, Provider 和 Consumer 仍然可以通过本地缓存通讯.
- Provider 无状态, 任意一台宕机后, 不影响使用. 
- Provider 全部宕机后, Consumer将无法使用,并会无限次重连等待 Provider 回复.



==**伸缩性:**==

- Register 对等集群, 可动态增加机器部署实例. 所有客户端将自动发现新的注册中心.
- Provider 无状态, 可动态增加机器部署实例. Register 将推送新的 Provider 信息给 Consumer.



==**升级型:**==



## 2. Dubbo 配置

