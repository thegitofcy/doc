# 线程文档内容索引

- 线程 8 大核心基础
    - 实现多线程的方法
    - 启动线程的正确和错误方法
    - ==停止线程的正确方法==
    - 线程的 6 个状态
    - Thread 和 Object类中和线程相关的重要方法
    - 线程的各种属性
    - 线程未捕获异常 UncaughtException 应该如何处理
    - 多线程会导致性能问题(线程引入的开销, 上下文切换)
- Java 内存模型



# 线程简介

- 线程就是独立的执行路径
- 在程序运行时, 即使没有创建线程,后台也会有多个线程, 如 main 线程, GC 线程
- main 线程是主线程, 为系统的入口, 用于执行整个程序.
- 在一个进程(process)中, 如果开辟了多个线程, 线程的运行由调度器安排调度, 调度器是和操作系统紧密相关的, 先后顺序无法人为干预.
- ==**对同一份资源进行操作的时候, 会存在资源抢夺的问题,需要加入并发控制.**==
- 线程会带来额外的开销, 比如 CPU 调度时间, 并发控制开销.
- ==**每个线程在自己的工作内存交互, 内存控制不当会造成数据不一致.**==

# 第一章 线程 8 大核心基础

## 1. 实现多线程的方法

==**Oracle 官网文档声明是: 两种!!! (继承Thread, 实现 Runnable)**==
- 方法一: ==实现 `Runnable` 接口并传入 `Thread` 类==
- 方法二: ==继承 `Thread` 类然后重写 `run()` 方法==
- 其实还可以通过 `Callable` 接口来实现有==**返回值**==的线程.

==**这个问题最精准的描述**== : 查看附录中的面试问题

### 1.1 继承 `Thread` 和实现 `Runnable` 演示, 以及 `Callable` 实现

```java
public class ThreadStyle extends Thread {
    @Override
    public void run() {
        System.out.println("继承 Thread 的方式实现多线程");
    }

    public static void main(String[] args) {
        new ThreadStyle().start();
    }
}

public class RunnableStyle implements Runnable {
    @Override
    public void run() {
        System.out.println("实现 Runnable 的方式实现多线程");
    }

    public static void main(String[] args) {
        new Thread(new RunnableStyle()).start();
    }
}

/**
 * 实现 Callable 的方式创建线程
 * 1. 实现 Callable 接口, 并指定返回值泛型
 * 2. 重写 call 方法
 * 3. 创建对象
 * 4. 创建 ExecutorService 服务
 * 5. 提交执行
 * 6. 获取返回值
 * 7. 关闭服务
 */
public class CallableExample implements Callable<Boolean> {

    private String url;
    private String targetName;

    public CallableExample(String url, String targetName) {
        this.url = url;
        this.targetName = targetName;
    }

    @Override
    public Boolean call() throws Exception {
        FileUtil.download(url, targetName);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableExample callable1 = new CallableExample("https://www.baidu.com/img/flexible/logo/pc/result@2.png", "1.jpg");
        CallableExample callable2 = new CallableExample("https://www.baidu.com/img/flexible/logo/pc/result@2.png", "2.jpg");
        CallableExample callable3 = new CallableExample("https://www.baidu.com/img/flexible/logo/pc/result@2.png", "3.jpg");

        // 创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        // 提交执行
        Future<Boolean> submit1 = executorService.submit(callable1);
        Future<Boolean> submit2 = executorService.submit(callable2);
        Future<Boolean> submit3 = executorService.submit(callable3);

        // 获取返回值
        Boolean aBoolean1 = submit1.get();
        Boolean aBoolean2 = submit2.get();
        Boolean aBoolean3 = submit3.get();

        // 关闭服务
        executorService.shutdown();
    }
```

### 1.2 两种方式的对比

==**结果: 使用 Runnable 的方式更好**==

==原因:==

1. 首先, Java 不支持多继承,限制了扩展性, 使用 Runnable 有更好的扩展性
2. 从代码架构上来说, ==**具体的任何(run方法)应该和"创建和运行线程的机制(Thread 类)"解耦,用 Runnable 对象可以实现解耦.**==
3. 使用继承 Thread 方式的话, 每次想创建一个任务, 就只能新建一个独立的线程, 而这样做的==消耗会比较大==(比如重新创建一个类, 继承 Thread, 再启动,执行,销毁. 如果线程的实际工作内容, 也就是 run 方法只是打印一行文字的话, 那么线程的实际工作内容还不如消耗来的大). ==使用 Runnable 和线程池就可以大大减少这样的消耗==

==两种方法的本质对比:==

两种方法在本质上, 并没有什么区别, 都是最终调用 `start()` 方法来新建线程. 主要区别在于 `run()` 方法的内容来源.
- 实现 Runnable : ==最终调用` target.run()`==, 也就是说调用的是 Thread 源码中的 run 方法, 只不过是使用传入的 Runnable 对象来调用的
    ```java
        // Thread 类源码
        private Runnable target;
        @Override
        public void run() {
            if (target != null) {
                target.run();
            }
        }
    ```
- 继承 Thread : ==`run()`整个都被重写==, 所以调用的其实是重写后的 run()方法.

### 1.3 同时使用两种方法会是什么结果?

```java
public class BothRunnableThread {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("我来自 Runnable!");
            }
        }){
            @Override
            public void run() {
                // super.run();
                System.out.println("我来自 Thread!");
            }
        }.start();
    }
}

运行结果: 我来自 Thread!
解析: 在 main 方法中, 创建了一个内部类 Thread, 并且 new 了一个 Runnable 给 Thread, 然后又重写了 Thread 的 run 方法
    前边讲过使用 Thread 和使用 Runnable 两种方式创建多线程的本质区别是两种方式的 run 方法的来源不同.
        实现 Runnable 接口是重写了 Runnable 的方法, 并把 Runnable 作为参数传递给 Thread 类, 通过 Thread 类的源码中的 Run 方法进行调用,最终调用的是 Runnable 方法的 run 方法.
        继承 Thread 的方式是重写了 Thread 的 run() 方法, 所以就把 Thread 源码中的经典的 run()方法给覆盖掉了.
    所以, 这段代码由于重写了 Thread 类的 run 方法, 在启动线程后执行的就是重写的 run 方法, 而父类 Thread 的 run 方法就不会得到执行,也就没有 target.run 这几行代码了, 所以 runnable 的 run 得不到执行,最终就只会输出 "我来自 Thread!"这一句话.

// super.run();    
如果把这行代码打开,那么就会先执行 "我来自 Runnable!", 再执行"我来自 Thread!", 因为调用了Thread 源码中的 run 方法.
```

### 1.4 一些错误的观点

1. =="线程池也是一种创建线程的方法. 这种说法不够准确"==

    ```java
    public class ThreadPoolStyle {
        public static void main(String[] args) {
            ExecutorService executorService = Executors.newCachedThreadPool();
            for (int i = 0; i < 1000; i++) {
                executorService.submit(new Task(){});
            }
            executorService.shutdown();
        }
    }
    
    class Task implements Runnable {
        @Override
        public void run() {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName());
        }
    }
    
    解析:
        跟源码可以发现, 底层使用的还是 new Thread 的方式.
        Executors.newCachedThreadPool()
    --> new ThreadPoolExecuto()
    --> Executors.defaultThreadFactory()
    --> new DefaultThreadFactory()
    --> newThread() 方法, 内部使用的是 new Thread() 构建 Thread 的方式.
    ```

1. =="通过` Callable` 和` FutureTask` 创建线程, 也算是一种新建线程的方式. 这种说法也不准确"==
2. ==*定时器 Timer, 它并不是一种新的创建线程的方式, TimerTask 实现 Runnable***==



## 2. 启动线程的正确和错误方法

==正确的启动方式是 start()方法==  run()方法其实并不是一种正确的启动线程的方法.



### 2.1 start() 和 run() 的比较

```java
public class StartAndRunMethod {
    public static void main(String[] args) {
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName());
        };
        runnable.run();

        new Thread(runnable).start();
    }
}

运行结果:
    main // 其实是主线程调用的.
    thread-0
```



#### ==**start()方法分析**==

- start() 的作用是启动新线程, 告知 JVM 这个线程可以运行了, 待分配到时间片就可以执行.
- start() 方法其实会让两个线程启动, 一个是主线程, 一个是新线程. `new Thread().start()`这句话就是主线程调用的.
- 不能重复的执行 start() 方法. `IllegalThreadStateException`



==start()方法的执行流程==

```java
 public synchronized void start() {
        
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
            
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
    private native void start0();

```
#### `start()` 方法执行流程:

1. 检查线程状态(`threadStatus`是否等于 0,新创建线程 `threadStatus` 初始化为 0.), 只有 new 状态下的线程才能启动(threadStatus == 0), 否则会抛出`IllegalThreadStateException`异常.
2. 加入线程组.
3. 调用 start0() (一个 native 方法) 方法启动线程. 



#### ==**run()方法分析**==

run()方法有两种情况, 一直是重写了 run() 方法, 一种就是传入 Runable, 调用 target.run()

```java
    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
所以在直接调用 run 方法的时候, 就是个普通方法.就没有通过创建的线程,而是直接通过主线程来调用的.
```





## 3. 停止线程的正确方法

==**总结: 使用` interrupt` 来通知, 而不是强制(强制的意思就是说使用 interrupt 通知线程终中断).**==



### 1. 线程通常会在什么情况下停止?

1. run 方法执行完毕了, 正常停止.
2. 抛出了异常, 也会停止.



### 2. 停止线程原理介绍

其实 Java 中, 最好的停止线程的方式是使用 `Interrupt`, 但是这仅仅是会通知到需要被停止的线程:你该停止运行了...==**被终止的线程自身拥有决定权(决定是否, 以及何时停止)**==. 这需要请求停止方和被停止方遵守约定好的规范.因为一段代码最好的情况就是自己运行结束. 即使是要停止, 也需要做一些后续操作, 比如关闭资源啊等, 具体怎么做后续操作只有这段代码知道的最清楚, 所以一般停止线程是通过 `interrupt`进行通知, 然后被要被停止的线程自己去决定是否要停止,或者什么时候停止.



### 3. 正确停止线程



#### ==普通情况下停止线程(没有阻塞)==

解析: 

1. 对线程 thread 调用 `interrupt()`进行打标, 说明这个线程需要进行停止
2. 然后在 thread 运行过程中, 使用 `isInterrupt()` 判断当前线程是否被打上了需要停止的标记, 如果打上了, 则使线程停止.例如 if 判断,只有在没有打标的情况下,才执行 thread 的线程体.

```java
public class InterruptExample {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                int num = 0;
                // 判断是否中断
                while (!Thread.currentThread().isInterrupted() && num < Integer.MAX_VALUE / 2) {
                    if (num % 10000 == 0) {
                        System.out.println(num + " 是 10000的倍数");
                    }
                    num++;
                }
                System.out.println("线程运行完毕");
            }
        });
        thread.start();
        thread.sleep(1000);
        // 为 thread 打标, 告知 thread 要进行中断
        thread.interrupt(); 
    }
}
```



#### ==线程允许阻塞(sleep)==

sleep 遇到 interrupt, 就会抛出异常

```java
public class StopThreadWhithSleep {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(50000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread.start();
        Thread.sleep(100);
        thread.interrupt();
    }
}
```

## 4. 线程的生命周期

## 5. Thread 和 Object类中和线程相关的重要方法

## 6. 线程的各种属性

## 7. 线程未捕获异常 UncaughtException 应该如何处理

## 8. 多线程会导致性能问题(线程引入的开销, 上下文切换)

## 线程池

核心:
- `ExecutorService`
- `Executors` 创建线程池的对象
频繁的创建和销毁线程对于系统的开销是很大的, 所以就可以通过复用的方式来解决这个问题, 比如线程池. 使用线程池来创建一组线程. 当有一组任务的时候, 在线程池中的一个线程执行完毕后, 不会销毁这个线程, 而是让他继续执行其他的任务, 已达到复用的效果.

Java 提供的线程池的对象是 `ExecutorService`, 它会接收一个任务, Java 提供的任务对象有两个, 一个是` Runnable`, 另一个是` Callable`, `Runnable`是没有返回值的任务, 而` Callable` 是有返回值的任务, 当任务执行完毕后, `Executor` 会返回一个` Future`结果.通过这个对象可以获取对应任务的信息, 比如任务是否完成, 可以使用` isDone()`方法. 如果是完成的状态, 就可以通过` get()`方法获取其他数据.

### ==Executors==
Java 提供的创建线程池的对象.

==可以创建以下几种线程池==
- `newSingleThreadExecutor` : 单线程的线程池
- `newFixedThreadPool` : 创建定长的线程池
- `newCachedThreadPool` : 当提交新任务, 如果当前线程池中有空闲的线程,就会使用这个线程来执行任务, 如果当前线程池中没有空闲的线程, 就会创建新线程来执行任务, 并把这个线程放入线程池中.
- `newScheduledThreadPool`: 创建定时线程. 如果提交的任务不想马上执行, 就可以创建这种线程池, 可以指定时间, 指定频率的执行任务.


## java提供的类
### java.util.concurrent
#### Callable<V> 接口
- `Callable<V>`是有返回值的接口. 
- 使用`@FunctionInterface`声明为了==函数式接口==. 
- 只有一个抽象方法 : `V call()`,此方法具有返回值. Callable 的泛型就是返回值类型. `call()`方法等同于`Runnable`的`run()`方法.
- `Callable`的实例不能作为`Thread`线程实例的==target==来使用, `Runnable`可以作为`Thread`实例的==target==, 开启一个线程.

在Java的线程类中, 只有一个`Thread`类, 没有其他的类型, 那么如果`Callable`需要异步执行, 就要想办法赋值给`Thread`的target成员, 即Runnable类型, 所以, Java提供了在`Callable`实例和`Thread`的target成员之间的一个塔桥的类---==FutureTask类==.

#### FutureTask类
为了获取异步线程的返回结果, java1.5后提供一种新的多线程创建方式 : ==FutureTask==. `FutureTask`包含了一系列的java相关的类, 在`java.util.concurrent`包中. 最重要的是`FutureTask`类和`Callable`接口.

- `FutureTask`位于`java.util.concurrent`包中.
- `FutureTask`简介的继承了`Runnable`接口, 从而可以作为`Thread`的==target==执行目标.
- `FutureTask`的构造函数的参数是`Callable`类型, 实际上是对`Callable`的二次封装.可以执行`Callable`的`call()`方法.
- `FutureTask`类就像是`Callable`和`Thread`线程实例之间的桥梁. `FutureTask`内部封装了一个`Callable`, 然后自身又作为`Thread`线程的==target==(因为`FutureTask`简介的继承了`Runnable`接口.)
- 在外部, 如果要获取`Callable`实例的异步执行的结果, 不是调用其`call`方法, 而是需要通过`FutureTask`类的相应方法去获取.
- 总体来说, `FutureTask`类首先相当于一个==搭桥类==的角色: `FutureTask`类能作为`Thread`线程去执行目标==target==, 被异步执行; 其次, 如果要获取异步执行的结果, 需要通过`FutureTask`类的方法去获取, 在`FutureTask`类的内部, 会将`Callable`的`call`方法的真正结果保存起来, 以供外部获取.

在Java语言中吗将`FutureTask`类的一系列操作抽象出了一个接口 : ==Future==接口. `FutureTask`类实现此接口.

#### Future接口
`Future`接口并不复杂, 主要是对==并发任务的执行==及==获取其结果==的一些操作.主要包括三道功能:
1. 判断并发任务是否执行完成
2. 获取并发任务完成后的结果.
3. 取消并发执行中的任务.

==Future源码==

```java
public interface Future<V> {
    /**
     * 取消并发任务的执行
     */
    boolean cancel(boolean mayInterruptIfRunning);
    /**
     * 获取并发任务的取消状态. 如果并发任务在执行完成之前被取消, 则返回true.
     */
    boolean isCancelled();
    /**
     * 判断并发任务是否执行完成, 如果执行完成, 返回true.
     */
    boolean isDone();
    
     /**
     * 获取并发任务执行的结果. 这个方法时阻塞性的. 如果并发任务没有执行完成, 调用此方法的线程会一直阻塞,直到并发任务
     * 执行完成
     */
    V get() throws InterruptedException, ExecutionException;
    /**
     * 获取并发任务执行的结果. 这个方法时阻塞性的. 但是会有阻塞的时间限制. 如果阻塞时间超过设置的timeout时间, 该
     * 方法会抛出异常.
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

#### Future和FutureTask
`FutureTask`类实现了`Future`接口, 提供了外部操作异步任务的能力. 为了完成异步执行`Callable`类型的任务, 获取任务结果, 在`futureTask`类的内部, 会有一些技能点:

- ==首先, 在FutureTask内部有一个Callable类型的成员, 代表异步执行的逻辑==

`private Callable<V> callable;`

`callable`实例属性必须要在`FutureTask`类的实例构造时进行初始化.

其次, 在`FutureTask`类内部有一个`run`方法, 这个run方法时`Runnable`接口的抽象方法, 在`FutureTask`内部提供了自己的实现. 在`Thread`线程执行实例时, 会将这个`run`方法作为==target==目标去异步执行.在`FutureTask`内部的`run`方法中, 会执行`Callable`的`call`方法. 执行完毕后, 就会结果保存在==**outcome**==中.

`private Object outcome;`

==outcome==保存的结果, 可供`FutureTask`类的结果获取方法来获取.(例如 `get()`方法.)

### com.google.common.util.concurrent
`com.google.common.util.concurrent`是谷歌公司提供的, 对`java.util.concurrent`的补充和扩展. 例如==Guava==的异步任务接口`ListenableFuture`, 扩展了java的`Future`接口. 实现了非阻塞获取异步结果的功能.

为了实现非阻塞获取异步线程的结果, ==Guava==对java的异步回调机制进行了一下增强:
1. 引入一个新的接口`ListenableFuture`, 继承了java的`Future`接口,是的java的`Future`异步任务, 在`Guava`中能被监控和获取非阻塞异步执行的结果.
2. 引入一个新的接口`FutureCallback`,这是一个独立的新接口, 该接口的目的==是在异步任务执行完后, 根据异步结果, 完成不同的回调处理, 并且可以处理异步结果== .

#### FutureCallback
`FutureCallback`是一个新增的接口, 用来填写异步任务执行完后的监听逻辑.`FutureCallback`有两个回调方法:
1. `onSuccess`方法, 在异步任务执行成功后被回调; ==调用时, 异步任务的结果,作为onSuccess方法的参数被传入==
2. `onFailure`方法, 在异步任务执行过程中,抛出异常时被回调; ==调用时, 异步任务所抛出的异常, 作为onFailure方法的参数被传入.==

==FutureCallback源码==

```java
package com.google.common.util.concurrent;

@GwtCompatible
public interface FutureCallback<V> {
  /** 在异步任务执行成功后被回调 */
  void onSuccess(@Nullable V result);

  /**
   * 在异步任务执行过程中,抛出异常时被回调.
   */
  void onFailure(Throwable t);
}

```

==FutureCallback和Callable的区别==
1. Java的`Callable`接口, 代表的是异步执行的逻辑.
2. `Guava`的`FutureCallback`接口, 代表的是异步逻辑执行完毕之后, 根据成功或异常两种情况, 所需执行的善后工作.


`Guava`是对Java Future 异步回调的增强. 使用`Guava`异步回调, 也需要用到java的`Callable`接口. 简单的说, 只有在java的`Callable`任务的执行结果出来后, 才能执行到`Guava`中的`FutureCallback`225.

`Guava`如何实现异步任务`Callable`和`FutureCallback`结果回调之间的监控关系? `Guava`引入了一个新的接口: `ListenableFuture`. `ListenableFuture`继承了`Future`接口, 增强了监控的能力.

#### ListenableFuture
`ListenableFuture`继承了`Future`接口, 是为了实现异步任务java的`Callable`和Guava的`FutureCallable`结果回调之间的监控关系.

==ListenableFuture接口源码==

```java
package com.google.common.util.concurrent;

public interface ListenableFuture<V> extends Future<V> {

  void addListener(Runnable listener, Executor executor);
}
```

`ListenableFuture`接口只添加了一个方法 : `addListener(Runnable listener, Executor executor)`, 它的作用是将`FutureCallback`善后回调工作, 封装成一个内部的`Runnable`异步回调任务, 在`Callable`异步任务完成后, 回调`FutureCallback`进行善后处理.==需要注意的是, addListener方法只在Guava内部调用. 实际编程中, 不会手动的调用addListener方法.==

在实际编程中, 如何将`FutureCallback`回调逻辑绑定到异步的`ListenableFuture`任务呢? 可以使用`Guava`的`Futures`工具类, 它有一个`addCallback`静态方法, 可以将`FutureCallback`的回调实例绑定到`ListenableFuture`异步任务.

#### ListenableFuture异步任务
如果要获取`Guava`的`ListenableFuture`异步任务实例, ==主要是通过向线程池(ThreadPool)提交`Callable`任务的方式来获取, 这里所说的线程池是指Guava自己定制的Guava线程池.==

Guava的线程池是对Java线程池的一种装饰. 创建Guava线程池的方法如下:

```java

```

