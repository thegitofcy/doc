# 线程

关键字: 线程工作内存. GC 线程. Callable 接口.

## 线程简介

- 线程就是独立的执行路径
- 在程序运行时, 即使没有创建线程,后台也会有多个线程, 如 main 线程, GC 线程
- main 线程是主线程, 为系统的入口, 用于执行整个程序.
- 在一个进程(process)中, 如果开辟了多个线程, 线程的运行由调度器安排调度, 调度器是和操作系统紧密相关的, 先后顺序无法人为干预.
- ==**对同一份资源进行操作的时候, 会存在资源抢夺的问题,需要加入并发控制.**==
- 线程会带来额外的开销, 比如 CPU 调度时间, 并发控制开销.
- ==**每个线程在自己的工作内存交互, 内存控制不当会造成数据不一致.**==



## 创建线程

创建线程方法: (建议实现 Runnable, 毕竟有单继承的限制)

1. 自定义线程类 `PrimeThread`, 实现 `Runnable` 接口, 重写 `run()` 方法. 作为 `Thread` 构造方法参数创建 `Thread`对象, 然后调用 `thread.start()` 方法启动线程;
2. 自定义线程类 `PrimeThread`, 继承 `Thread` 类, 重写 `run()` 方法. 创建`PrimeThread`对象 `p`, 调用 `p.start()`方法启动线程;
3. 实现 `Callable` 接口, 可以返回值, 可以抛出异常;

```java
// 继承 Thread 类, 重写 run() 方法
public class PrimeThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("PrimeThread --- " + i);
        }
    }

    public static void main(String[] args) {
				// 创建线程对象, 调用 start() 启动线程
        PrimeThread primeThread = new PrimeThread();
        primeThread.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("main --- " + i);
        }
    }
}

// 实现 Runnable 接口, 重写 run()方法, 作为 Thread 的构造参数创建Thread 对象
public class PrimeRunnable implements Runnable{
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println("PrimeRunnable === " + i);
        }
    }

    public static void main(String[] args) {
        new Thread(new PrimeRunnable()).start();

        for (int i = 0; i < 200; i++) {
            System.out.println("mian === " + i);
        }
    }
}

/**
 * 模拟卖票
 */
@Slf4j
public class TicketThread implements Runnable {

    private int ticketNums = 10;

    @Override
    public synchronized void run() {
        while (ticketNums > 0) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("[{}] 拿到了第 [{}] 张票!", Thread.currentThread().getName(), ticketNums--);
        }
    }

    public static void main(String[] args) {
        TicketThread ticketThread = new TicketThread();

        new Thread(ticketThread, "老王").start();
        new Thread(ticketThread, "老张").start();
        new Thread(ticketThread, "黄牛").start();
    }
}

/**
 * 实现 Callable 的方式创建线程
 * 1. 实现 Callable 接口, 并指定返回值泛型
 * 2. 重写 call 方法
 * 3. 创建对象
 * 4. 创建 ExecutorService 服务
 * 5. 提交执行
 * 6. 获取返回值
 * 7. 关闭服务
 */
public class CallableExample implements Callable<Boolean> {

    private String url;
    private String targetName;

    public CallableExample(String url, String targetName) {
        this.url = url;
        this.targetName = targetName;
    }

    @Override
    public Boolean call() throws Exception {
        FileUtil.download(url, targetName);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableExample callable1 = new CallableExample("https://www.baidu.com/img/flexible/logo/pc/result@2.png", "1.jpg");
        CallableExample callable2 = new CallableExample("https://www.baidu.com/img/flexible/logo/pc/result@2.png", "2.jpg");
        CallableExample callable3 = new CallableExample("https://www.baidu.com/img/flexible/logo/pc/result@2.png", "3.jpg");

        // 创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        // 提交执行
        Future<Boolean> submit1 = executorService.submit(callable1);
        Future<Boolean> submit2 = executorService.submit(callable2);
        Future<Boolean> submit3 = executorService.submit(callable3);

        // 获取返回值
        Boolean aBoolean1 = submit1.get();
        Boolean aBoolean2 = submit2.get();
        Boolean aBoolean3 = submit3.get();

        // 关闭服务
        executorService.shutdown();
    }
}

```

