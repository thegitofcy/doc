# 线程面试问题以及零碎的点

## 零碎的点

### 当 sleep 遇到 interrupt 的时候

sleep 的时候, 如果检测到 interrupt, 则会抛出异常 `java.lang.InterruptedException: sleep interrupted` 异常! 并且会 ==**清除interrupt停止线程的标记**==, 所在当在一个 while 中, 如果在 while 内部 try/catch sleep, 那么并不会使线程停止.



### 线程 Blocked 状态和 Waiting 状态

当线程进入到被 `synchronized`修饰的代码块的时候, 并且锁已经被其他线程拿走了, 那么这个线程就进入 Blocked 状态. Blocked 状态只针对 `synchronized` 关键字.

Blocked 是需要其他线程释放一个 `Monitor`锁(排它锁). waiting 状态是等待被唤醒或者是等待时间结束.



## 常见面试问题

### 线程

### 1. 实现多线程的方式

通常可以分为两类,Oracle 也是这样说的, 一种是实现 Runnable 接口, 另一种是继承 Thread 类.

准确的讲, ==创建线程只有一种方式==, 那就是==构建 Thread 类==,只不过实现线程的执行单元有两种方式:

- 方法一: 实现 Runnable 接口的 run 方法, 并把 runnable 对象传递给 Thread. 最终调用的是` target.run()` 这一行
- 方法二: 继承 Thread 类, 重写run 方法.

==继承 Thread 类, 重写run 方法== 和 ==实现 Runnable 接口, 并作为构造参数传入 Thread==这两种创建线程的方式其实本质上并没有却别, 都是最终调用 `start()` 方法来新建线程, 只不过 `run()`方法的来源不同.

除此之外, 线程池等也可以创建线程,但是==他们的本质也都逃不出刚才所说的范围.==



### 2. 一个线程调用两次 start()方法会出现什么情况?为什么?

start()方法最开始的时候就会检查线程状态是否正确, `threadStatus != 0`, 如果不正确(不等于 0)就会报出 `IllegalThreadStatusException`.  `threadStatus` 初始化时候为 0.

### 3. 为啥要通过 start() 来启动线程,而不使用 run()方法.

因为 start() 才是真正意义上启动线程的方法, 并且还会==**检查线程的状态**==等.
而 run() 方法就是个普通的方法, 并不会通过子线程去调用, 而是通过主线程调用.

### 4. 如何停止一个线程





### 5. 如何处理不可中断的阻塞



