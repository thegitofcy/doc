# 1. JMM 作用

为了屏蔽掉 java 程序在不同的平台和操作系统中内存访问的差异, 实现 ==**java 程序在不同的平台上都能达到内存访问的一致性**==. JVM 就定义了 java 内存模型.

 ==**JMM规范**==了一个线程如何和何时可以访问到由其他线程修改过后的共享变量的值, 以及在必须时如何同步的访问共享变量. 

总结一句话:==**Java 内存模型的主要目标是定义变量的访问规则.也就是在虚拟机中将变量存储到主内存或者从主内存取出的底层细节.**== 





# 2. 主内存和本地内存

## 1. 主内存和本地内存

- JVM 运行程序的实体是线程.
- 每个线程创建时, JVM 都会为其创建一个==**工作内存(其实并不是真的给每个线程分配一块内存空间, 而是JMM 的一个抽象,  对寄存器, 一级缓存, 二级缓存等的抽象.)**==.工作内存是每个线程的==**私有数据区域**==.
- 而 java 内存模型中规定所有变量都存储在==**主内存**==中, ==**主内存是所有线程共享内存区域, 所有线程都可以访问**==.
- 但是线程对变量的操作必须在工作内存中完成, 首先需要从主内存中将变量拷贝到自己的工作内存中, 然后对变量进行操作,操作完后再写回主内存中. 不能直接操作主内存的变量. 各个线程存储这主内存的==**变量的副本拷贝**==.
- 基于以上原因, ==**不同的线程无法访问其他线程的工作内存.线程间的通信必须通过主内存来完成**==.

<img src="/Users/cy/develop/doc/local/picture/并发/image-20200905111440268.png" alt="image-20200905111440268" style="zoom:50%;" />





## 为什么会有可见性问题

<img src="/Users/cy/develop/doc/local/picture/并发/image-20200905112059789.png" alt="image-20200905112059789" style="zoom:50%;" />

- RAM: 内存(包含 L3 cache).L3cach3, L2cache,L2cache都是缓存. Registers: 寄存器, core: CPU . 将寄存器, L1,L2 抽象为工作内存. L3 和 RAM 是主内存.
- 速度由下而上越来越快
- 之所以在 CPU 和内存中间加上缓存和寄存器, 是因为 CPU 的速度要比内存快的多, 如果不加上缓存和寄存器, 会降低 CPU 的效率.比如 CPU 运行一次需要 1ms, 但是内存运行一次需要 100ms, 如果不加缓存和寄存器, 那么 CPU 运行一次的时间会因为内存的原因, 变为 100ms.
- 对于同一个变量a, core4操作完后, 写回到 L2后, 由于 L2的速度比 L3 快, 还未写回到 L3, 此时 core1 读取 L3 的数据, 读取的是未写回前的数据, 就造成了可见性问题.



==更加准确的说法:==

- CPU 有多级缓存, 导致读的数据过期.
  - 高速缓存的容量比主内存小,但是速度仅次于寄存器, 所以在 CPU 和主内存之间就多了 cache 层.
  - 线程间对于共享变量的可见性问题不是直接由多核引起的, 而是由==**多存缓存**==引起的(就是上边那个图).



==总结==:

- JMM 抽象出了工作内存和主内存的概念.
- 各个线程只能操作自己的工作内存, 而工作内存中的数据是来自于主内存, 操作完后, 吧数据写回到主内存.
- 而工作内存和主内存之间, 由于多级缓存操作速度的原因, 会造成数据的过期(数据不是实时的).
- 这就造成了可见性问题.



# 3. JMM 同步操作

由于多个线程操作同一个共享变量的时候, 由于多级缓存的原因(多级缓存是造成数据可见性问题的根本原因), 会出现数据不同步的问题, 所以在多线程操作同一个共享变量的时候, 为了保证数据的正确性, 我们需要进行一定的同步手段, 比如使用 volatile, Synchronized 等关键字.

所以, JMM 对于同步操作定义了 ==**8 个操作和几个规则**==.



## 1. 数据同步的8 个操作以及相关规则

### 数据同步 8 个操作

==**作用于主内存:**==

- lock: 作用于主内存的变量, 把一个变量标记为一条线程独占状态.
- unlock: 作用于主内存的变量,把一个被 lock 的变量释放出来, 释放后的变量才可以被其他线程 lock.
- read: 作用于主内存的变量. 把一个变量从主内存传输到工作内存中, 以便随后的 load 操作使用.

==**作用于工作内存:**==

- load: 作用于工作内存的变量, 把通过 read 操作从主内存中载入的变量放入工作内存的变量副本中.
- use: 作用于工作内存的变量. 把工作内存中的一个变量传递给执行引擎.
- assign: 作用于工作内存的变量, 把一个从执行引擎接收到的值(改变后的值)复制给工作内存中的变量.
- store: 作用于工作内存的变量, 把工作内存中的一个变量传到主内存中, 以便后边的 write 操作.

==**作用于主内存:**==

- write: 作用于主内存的变量. 把 store 操作从工作内存中的一个变量传送到主内存的变量中.



<img src="/Users/cy/develop/doc/local/picture/JMM/image-20200907153504243.png" alt="image-20200907153504243" style="zoom:33%;" />

操作执行顺序, 例如对于变量 `a = 1;`:

`lock(a=1, 当前线程独占) -> read(a=1) -> load(副本a=1) -> use(副本a=1, 执行引擎进行计算) -> assing(计算后, 副本a=2) -> store(传递到主内存) -> write(主内存a=2) -> unlock(解除独占状态)`



### 相关规则

- 一个变量在同一时刻只允许被一条线程对其进行 lock 操作.但是 lock 操作可以被这个线程多次执行, 执行多次 lock 后, 要执行相同次数的 unlock 操作, 变量才会被解锁. lock 和 unlock 必须成对出现.
- 如果一个变量没有被 lock, 则不允许对它进行 unlock 操作. 也不允许去 unlock 一个被其他线程 lock 的变量.

- 如果要从主内存向工作内存读取数据, 那么 read 和 load 必须是==**按照顺序执行**==. 如果要从工作内存向主内存写入数据, 那么 store 和 write 则必须==**按照顺序执行**==.  ==**但是 JMM 只是规定了 read/load 和 store/write 必须按照顺序执行, 并没有规定必须要连续执行,**== 也就是说 read/load 中间可以插入其他操作, store/write 操作也一样.
- 不允许 read 和 load 操作单一出现, 就是说 read 后必须要有 load 操作. store/write 也一样.
- 不允许一个线程丢弃它的最近的 assign 的操作.就是说变量在工作内存中改变后,需要要同步到主内存中.
- 不允许一个线程无原因的(没有发生任何 assign操作)把数据从工作内存同步到主内存. 也就是说在 assign 之前, 不允许将变量从工作内存同步到主内存, 想要吧数据从工作内存同步到主内存, 必须要先 assign.
- 一个新的变量只能在主内存中诞生.不允许在工作内存中直接使用一个未初始化(load 或 assign)的变量. 也就是说在进行 use 和 store之前, 必须要先 load 和 assign
- 对一个变量执行 unlock 之前, 必须先把此变量同步到主内存中.(执行 store 和 write 操作).
- 对一个变量进行 unlock 操作, 将会清空工作内存中此变量的值, 在执行引擎使用这个变量前需要执行 load 或 assign 操作初始化变量的值.