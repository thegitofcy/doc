# 1. 概念引入

## 1. 并发与高并发

### 1. 并发

- 同时有两个或者两个以上的线程.
- 运行在单核机器上: 这些线程交替的换入换出内存, 这些线程是"同时"存在的, 每个线程都处于某个状态.
- 运行在多核机器上: 每个线程都会被分配到一个处理器核上,所以可以同时运行.

### 2. 高并发

- 通过设计保证系统可以==**同时并行处理**==很多请求.



### 3. 并发和高并发不同的侧重点

并发:讨论并发时, 更多的是讨论多个线程操作相同的资源, 怎么保证线程安全, 合理利用资源.

高并发: 讨论高并发时, 系统短时间内接受到大量请求, 处理这种情况的手段, 比如系统优化, 算法优化, 架构设计等



## 2. 并发的优势与风险

### 1. 优势

#### 速度: 

可以同时处理多个请求, 响应的时间更快. 复杂的操作可以分为多个进程同时进行.

#### 设计:

程序设计时, 在某些情况下更简单, 也可以有更多的选择.

例如: 要设计一个读取和处理文件的系统, 如果手动编写读取和处理的顺序的时候, 就需要记录没个文件读取和处理的状态, 如果使用多线程并发处理, 就可以启动多个线程, 然后每个线程处理一个文件的读取和操作,线程在等待磁盘读取文件的时候, 会被阻塞, 在等待的时候, 其他线程就可以使用 CPU去处理已经读取完的文件. 结果就是磁盘总是繁忙的读取不同的文件到内存中, 这样可以提升磁盘和 CPU 的利用率,而且每个线程只要记住一个文件的状态.

#### 资源利用:

CPU 能在等待 IO(磁盘 IO 或者网络 IO) 的时候做一些其他的事情.比如上边的例子, 线程等待磁盘读取文件的时候会被阻塞, 其他线程可以利用这段时间做其他的事情.

### 2. 风险

#### 安全性

多个线程处理共享数据的时候可能会产生预期不符的结果.也就是==**线程安全问题**==.

### 活跃性

某个操作无法继续向下进行操作的时候, 会发生活跃性问题, 比如 死锁, 饥饿. 

### 性能

线程过多会使得 CPU 频繁切换, 调度时间增多, 同步机制, 消耗过多内存.



# 2. 线程安全

## 1. 线程安全概述

==**线程安全**==: 代码所在的进程有多个线程在同时运行, 这些线程可能会同时运行同一段代码, 如果运行结果和单线程环境下运行的结果一样,并且其他变量的值也和预期一样, 那么就是线程安全的. 简单的说就是: ==在并发环境下, 可以得到预期的值, 那么就说是线程安全的.==

当多个线程访问某个类时, 不管运行时环境采用==何用调度方式==或者这些进程如何交替进行,并且在主调代码中==不采用任何额外的同步或协调==, 这个类都能表现出==正确的行为==, 那么就称这个类是==线程安全的==.

==线程安全性体现在三个方面:==

1. ==**原子性**==: 提供了==互斥访问==, 同一时间==只能有一个线程==来对它进行操作.
2. ==**可见性**==: 一个线程对==主内存的修改==可以及时被其他线程观察到.
3. ==**有序性**==: 一个线程观察其他线程中的指令执行顺序, 由于 ==指令重排序== 的存在, 该观察结果一般杂乱无序.

## 2. 原子性

原子性提供了互斥访问, 也就是同一时间只能有一个线程对它进行访问.



### 1. Java 中保证原子性操作的措施

==**java 默认提供的保证了原子性操作的有:**==

1. 除了 long 和 double 之外的其他基本类型的赋值操作.(java 规定了对 64 位的赋值操作会被分为 2 个 32 位的赋值操作. 这样在多线程环境中, 就会出现问题).
2. Juc.Atomic包下的类
3. 引用类型的复制

==**自己实现的原子性操作:**==

1. Synchronized锁: 依赖jvm实现锁.
2. Lock 锁: 依赖特殊的 CPU 指令.



### 2. Synchronized



# 3. CAS

## 1. 什么是 CAS

- CAS: compare and swap, 即比较再转换.

- juc 包下的类使用 CAS 算法实现了区别于 Synchronized 同步锁的一种==**乐观锁**==. 

## 2. CAS 算法理解

CAS 是一种==**无锁算法**==,有 3 个操作数, ==**内存值 V, 旧的预期值 A, 要修改的新值 B**==, ==**当且仅当预期值 A 和内存值 V 相等时, 将内存值修改为 B, 否则什么也不做**==.



==**就是对主内存的数据和工作内存数据副本进行比较, 如果相等, 说明没有被修改, 那么就进行更新, 如果不相等, 则说明已经被修改了, 就不作操作了!**==



==**CAS 伪代码:**==

```java 
do{
  备份旧数据;
  基于旧数据构建新数据
} while(内存地址, 备份的旧数据, 新数据)
```

<img src="/Users/cy/develop/doc/local/picture/并发与高并发/image-20200907210112135.png" alt="image-20200907210112135" style="zoom:50%;" />

如上图:

1. t1 和 t2线程同时去访问同一个变量 56, 他们会把主内存中的值拷贝一份到工作内存, 所以 t1 和 t2 的预期值都是 56.
2. 加入 t1 先抢到了资源, 那么 t1 就能去更新值, 其他线程都抢占失败(抢占失败的线程并没有挂起, 而是尝试继续抢占), 此时 t1 会拿预期值和内存中的值比较, 发现都是 56, ==相等, 就更新值==, 并且会主内存, 此时主内存中的值是 57.
3. 这时候 t2 抢到了, 此时 t2 的预期值是 56, 但是内存中的值是 57, ==不相等, 就操作失败==了, 就啥也并不做了.

用比较通俗的话说: ==CPU 去更新一个值, 如果想修改的值不是原来的值, 则操作失败.==

就是说两者比较, 如果相等,说明没有被修改过, 则替换成新值, 然后继续运行, 如果不相等, 说明共享数据已经被修改了, 那么就放弃已做的操作.



## 3. CAS 的 ABA 问题.

### CAS 的 ABA 问题解释

ABA 问题是指在 CAS 操作的时候, 其他线程将变量的值修改为了 B, 但是因为一些原因, 有修改为了 A. 于是, CAS就将变量的值做了交换操作, 结果和预期肯定不符合.

例如:

1. 小明去取钱, 当前卡上有 200 块钱. 比如他要取 100
2. 取款机出了点问题, 小明点了 2 次, 发起了 2 个线程, 这两个线程都是期望获取 200, 然后更新为 100.
3. 加入线程 1 首先执行成功,将余额更新为了 100, 线程 2 由于某些原因阻塞了, 在线程 2阻塞的过程中, 小明的爸爸给小明又汇了 100, 这时卡上就有 200 的余额.
4. 这个时候线程 2 恢复运行, 阻塞之前获取到的是 200, 线程 2 就拿着这个 200和当前实际的值就行比较, 然后就把余额更新为 100 了.



### CAS 的 ABA 问题解决方案:

使用==**版本号**==, 比如时间戳, 就是说在 CAS 操作的时候, compare 不仅要比较期望的值和地址中的值是否一致,还要比较变量的版本号是否一致. 每次成功更新的时候, 版本号加 1.



### AtomicStampedReference

AtomicStampedReference 类就实现了用版本号