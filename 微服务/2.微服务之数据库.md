# 分布式之数据库

## 1. 最终一致性

​	在多个城市, 部署多个数据库, 这样的叫做 ==**异地多活**==. 为了保证==数据最终用一致性==.

​	例如: 上海有一个机房, 有一个 master, 主要是为了写入数据, 还有多个 slave, 主要是为了备份数据! 那么 master 和slave 之间就会有个同步的过程. 那么在写入 master 的时候, 是无法保证多个 slave 之间是同时一样的, 毕竟同步是需要时间的, 也就是==**无法保证强一致性**==.

​	假如深圳也有一个机房, 也有一个 master 和多个 slave.那么根据 CDN, 假如此时是注册, 那么离上海比较近的用户往上海的 master 的 user 表写, 离深圳比较近的用户往深圳的 master 的 user 写, 此时写的虽然不是同一个 master, 但是是相同一张表, 但是架构需要保证可用性, 也就是上海的跪了, 深圳还可以顶上去!所以肯定要保证两边的 master 数据一样, 这样两边的 master 就也存在一个同步的过程, 如果此时用的主键生成策略是自增的, 那么两边一同步, 可能就会发生主键冲突的情况,也就是 ==主主冲突==. 

​	为了解决这种情况, ==要么不使用自增主键. 要么使用 异地双活! 也就是一边以单数自增, 另一边以双数自增==! 例如上海写入的主键为 1, 3, 5...深圳写入的主键为 2, 4, 6...这样两边合并就不会发生主键冲突的情况.



​	假如又有一个 master, 此时就有了 3 个 master, 这种情况就叫做 ==异地多活==, 此时可以使用 ==UUID==. 虽然使用 UUID 可以解决主键冲突, 但是字符串影响搜索性能. 所以 ID 必须是数字, 那么这里就引出一个新的玩意: ==分布式 ID==.分布式 ID 可以保证主键唯一, 而且是数字, 只不过要牺牲一丢丢的可用性.

