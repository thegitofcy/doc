# 1. JVM 整体结构

## 1. JVM 整体结构

​	java 虚拟机是解释运行 ==class文件(字节码文件)==的, 通过==类加载器==, 将字节码文件装载到内存当中, 生成一个 class 对象, 这个过程涉及到 `加载, 链接, 初始化`. 将字节码文件加载到==运行时数据区==后, 就要通过==执行引擎==进行解释运行.

<img src="/Users/cy/develop/doc/local/picture/JVM/image-20201008192122363.png" alt="image-20201008192122363" style="zoom:50%;" />

- 字节码文件: 也就是 `.class` 文件, `.java` 程序经过==编译器==编译后, 形成字节码文件, 每个字节码文件都对应一个类(对象).然后字节码文件进行解释执行.
- 执行引擎: 操作系统只能识别机器指令, 无法识别字节码指令, 所以需要借助执行引擎来将字节码指令翻译成操作系统可以识别的机器语言.



## 2. Java 代码执行流程

<img src="/Users/cy/develop/doc/local/picture/JVM part1-内存与垃回收器/image-20201008193517726.png" alt="image-20201008193517726" style="zoom:50%;" />	

​	Java 源代码通过编译器编译后(第一次编译), 形成字节码文件, 字节码文件通过类加载器加载到 JVM 中, 然后通过执行引擎(翻译字节码/==JIT 编译器==)将字节码指令解释翻译为机器指令, 然后操纵系统进行运行.

​	执行引擎是 JVM 比较核心的内容之一. 目前市面上主流的虚拟机都采用了`解释执行和编译执行并存的方式`.

- 翻译字节码: 实时的根据字节码文件一行一行的进行解释执行.

- JIT 编译器: 在字节码文件中, 有一些代码是需要重复运行的, 也即是热点代码, JIT编译器 就会将这些热点代码的字节码指令再编译成机器指令(第二次编译), 然后==缓存到方法区当中==, 下次执行调用. ==所以 JIT 编译器和运行的性能有关==



## 3. JVM 指令集架构模型

JVM 的指令集架构基本上就 2 种: `基于栈的指令集架构` 和 `基于寄存器的指令集架构`.



基于栈的指令集架构特点:

- 设计和实现比较简单, 适用于资源受限的系统.
- 避开了寄存器的分配难题: 使用`零地址指令`方式分配.
- 指令流中大部分的指令都是`零地址指令`, 执行过程依赖于操作栈. `指令集更小(8位字节进行对其)`, 编译器容易实现. 相对于基于寄存器的指令集架构来说, 性能会降低, 实现同样的功能需要更多的指令.
- 不需要硬件支持, 可以移植性更好, 能更好的实现跨平台.
- 总结: 基于栈, 所以跨平台性好, 指令集小, 但是为了完成同样的功能需要更多的指令. 执行性能相对于基于寄存器的指令集架构要差一些.



基于寄存器的指令集架构特点:

- 指令集架构完全依赖硬件, 可移植性差.
- 指令要通过 CPU 执行, 由于操作数直接放在寄存器中,寄存器的速度非常快(至少相对于栈来说要快),所以性能就很优秀,执行更高效. 
- `花费更少的指令(16 位字节进行对其)`去完成一个操作.所以相当于基于栈的指令集架构来说, 可以通过更少的指令去完成一个操作.
- 大部分情况下, 基于寄存器的指令集架构的指令集往往都以一地址指令/二地址指令/三地址指令为主.



`HotSpot`使用的是 `基于栈的指令集架构`,  HotSpot任何的操作都要经过 `入栈`和`出栈`的操作. Java 代码的执行其实可以看做是通过一个一个的方法来实现的, 每运行一个方法, 就是一个入栈的操作, 栈顶就是当前正在执行的方法, 方法执行完毕后, 进行出栈操作.



- 零地址指令: 对应的还有一地址指令和二地址指令,以及三地址指令. 一地址指令就是说==如果想要执行一个指令, 那么就需要一个地址和一个操作数==, 二地址指令就是需要两个地址. 零地址就是不需要地址,只有操作数. 因为栈的会只有两个操作: 入栈和出栈, 也就是说操作栈的话其实就是操作的栈顶的数据, 所以不需要地址.



==**总结**==: 由于跨平台性的设计, Java 的指令都是根据栈来设计的. 不同平台的 CPU 架构不同, 所以不能设计为基于寄存器的.





## 4. JVM 的生命周期

`启动, 执行, 退出`



### 1. 虚拟机的启动

Java 虚拟机的启动是通过`引导类加载器(bootstrap class loader)`创建一个`初始类(initial class)`来完成的.这个类是由虚拟机的具体实现指定的.也就是说不通的实现商创建的初始类是不同的. 



也就是说,当要执行一个自己编写的 main 方法的时候,由于 java 中



### 2. 虚拟机的执行