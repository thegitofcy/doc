# 网络协议

- RPC
- TCP/IP
- HTTP

## 引入网络分层
![](media/15622131447710/15622152465122.png)

上图也称作 `OSI 七层模型` :
1. 应用层 : 最常用的服务是向用户提供访问网络的接口. 比如 `Telnet 远程登录协议`, `FTP 文件传输协议`, `SMTP 电子邮件协议`, `HTTP协议`等
2. 表示层 : 数据格式化, 代码转换, 数据加密等. ==这一层没有协议==. 就是说没有协议是在这一层的.
3. 会话层 : 解除或提供两个进程之间建立, 维护和结束会话连接的功能. 提供交互会话的管理功能, 比如三种数据流方向的控制,即一路交互, 两路交替和两路同时会话模式, ==这一层也没有协议==.
4. 传输层 : 指定了控制网络层的协议, 就像数据链路层控制物理层一样, 传输层和数据链路层都定义了流控和差错机制. 二者的不同在于数据链路层协议强调控制数据链路上的流量, 即连接两台设备的物理介质上的流量; 而传输层控制逻辑链路上的流量,即两台设备的端到端的连接, 这种逻辑连接可能跨越一连串数据链路. 在本层上的协议有 `TCP 协议`, `UDP 协议`等.
5. 网络层 : 主要负责定义数据包合适和地址格式.为经过逻辑网络路径的数据进行路由选择. 在这一层的协议有 `IP 协议`, `ICMP 协议`, `ARP 协议`等
6. 数据链路层 : 包含了控制物理层的协议, 比如访问和共享介质, 怎样标识介质上的设备, 以及在介质上发送数据之前如何完成数据成帧. 典型的数据链路协议有 `以太网协议`等
7. 物理层 : 包含了多种与物理介质相关的协议, 这些物理介质用以支撑 `TCP/IP`通信. 以二进制数据形式在物理媒介上传输数据.

这些分层, 每一层都有自己的功能, 就想建筑物一样, 每一层都靠下一层支持. 用户接触到的只有最上层, 根据感觉不到下面的层.

==**越向下,越接近硬件, 越上面的层,越靠近用户**==

**下图是 `TCP/IP 协议`的分层图示**
![](media/15622131447710/15622158757729.png)


## 第一章. RPC 远程过程调用
==RPC(Remote Procedure Call)==: 远程过程调用. 简单的理解是一个节点请求另一个节点提供的服务. ==**例如**==: 吃完饭后, 女友对你说: 去把碗洗了....这是本地过程调用! 吃完饭后, 女友出去玩了, 给你打电话说:去把碗洗了...这就是远程过程调用...







## 第二章. TCP/IP 协议

### 1. 概述
- 很多不同的厂家生产各种型号的计算机, 他们运行完全不同的操作系统, 但 `TCP/IP协议族` 允许他们互相进行通信.

==**信息汇总**==
- TCP 协议是面向连接的通信协议.
- 通过==三次握手==建立连接, 通讯完成时要拆除这些连接.
- 由于 TCP 协议是面向连接的, 所以只能用于端到端的通讯.(==某一个时刻只能连接到一个端口==).
- `TCP`发送消息后要收到回应.(==UDP 只管发送,不管目标收没收到==).
- TCP/IP 协议中, 两个进程间通信的主要模式为: ==CS 模型==.

#### 1.2 分层
  网络协议通常分为不同层次进行开发, 每一层分别负责不同的通信功能.  
  比如 `TCP/IP` 协议族,就是一组不同层次上的多个协议的组合, `TCP/IP` 协议通常被认为是一个四层协议系统.

![](media/15622097530660/15622107776929.jpg)


上图就是 `TCP/IP` 协议族的分层.每一层负责不同的功能 :

1. 应用层, 负责处理特定的应用程序细节. 几乎各种不同的 `TCP/IP` 实现都会提供以下这些通用的应用程序:
    - `Telnet` 远程登录
    - `FTP` 文件传输协议
    - `SMTP` 简单邮件传送协议
    - `SNMP` 简单网络管理协议  
    
1. 传输层, 也叫运输层. 主要为两台主机上的应用程序提供端到端的通信. 在 `TCP/IP` 协议栈中两个互不相同的传输协议 : `TCP(传输控制协议)` 和 `UDP(用户数据报协议)`.
    - `TCP` : 为两台主机提供高可靠性的数据通信. 它所做的工作包括 把应用程序交给它的数据==分割成合适的小块==交给下面的网络层, 确认接收到分组, 设置发送最后确认分组的超时时钟等. 由于传输层提供了高可靠行的端对端通信, 所以应用层可以忽略所有这些细节.
    - `UDP` : 为应用层提供一种非常简单的服务, 它只是把称作数据报的分组从一台主机发送到另一台主机, 但并不保证该数据报能到达另一端. 任何必须的可靠性必须由应用层来提供.  
2. 网络层, 也称作互联网层. 处理分组在网络中的活动. 例如分组的选路. 在 `TCP/IP` 协议栈中, 网络层协议包括 `IP(网际协议)`, `ICMP(Internet 互联网控制报文协议)`, `IGMP(Internet 组管理协议)`.

3. 链路层. 也称作数据链路层或网络接口层. 通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡, 他们一起处理与电缆(或者其他任何传输媒介) 的物理接口细节.

#### 1.3 两台主机之间的 TCP/IP 协议图解
假设在一个局域网(`LAN`),如以太网中有两台主机, 二者都运行 `FTP` 协议, 下图列出了该过程所涉及到的所有协议 : 

![](media/15622097530660/15622142446017.png)

上图列举了一个 ==FTP客户程序== 和另一个 ==FTP 服务器程序==. 大多数的网络应用程序都设计成 ==客户端-服务器模式==. 服务器为客户端提供某种服务, 在这个例子中, 就是访问服务器所在主机上的文件. 在远程登录应用程序` Telnet` 中, 为客户提供的服务是登录到远程服务器主机上.

在同一层上, 双方都有一个或者多个协议进行通信. 例如, 某个协议允许 TCP 层进行通信, 而另一个协议在允许两个 IP 层进行通信.

在上图的右边, 应用程序通常是一个用户进程, 而下三层则一般在(操作系统)内核中执行,尽管这不是必须的,但是一般都这么干, 例如 Unix 操作系统.

在上图中,顶层和下三层还有一个关键的不同之处, 应用层关心的是应用程序的细节, 而不是数据在网络中的传输活动, 而下三层对应用程序一无所知,但是他们要处理所有的通信细节.

上图中一共列列举了 4 种不同层次上的协议, `TCP` 是传输层协议, `IP` 是一种网络层协议, 而 `以太网` 是一种链路层协议. ==**所以 `TCP/IP` 协议栈是一组不同的协议组合在一起构成的协议栈. 尽管叫做 `TCP/IP 协议`, 但是 `TCP` 和 `IP` 只是其中的两种协议而已**==.

#### 1.4 TCP/IP 通信传输流
下图是 `TCP/IP协议` 通信传输流图示.

利用 `TCP/IP 协议栈` 进行网络通信时, 会通过分层顺序与对方进行通信, ==**发送端从应用层往上走, 接收端从链路层往上走**==.

![](media/15622097530660/15622160202318.png)


图解 :
- 首先, 作为发送端的客户端在应用层(`HTTP 协议`) 发出一个想看某个 Web 页面的 HTTP请求
- 接着,为了传输方便, 在传输层(`TCP 协议`) 把从应用层接收到的数据(HTTP 请求报文) 进行分割, 并在各个报文上打上标记序号及端口号后转发给网络层.
- 在网络层(`IP 协议`), 增加作为通信目的地的 MAC 地址后转发给链路层, 这样一来,发往网络的通信请求就准备齐全了.
- 接收端的服务器在链路层接收到数据, 按序往上层发送, 一直到应用层. 当传输到应用层, 才能算真正的接收到由客户端发送过来的 HTTP 请求.

### 2. TCP 协议详解
`TCP 协议` 是互联网的核心协议之一. ==是面向连接的端到端通信协议, 发送数据后要收到回应.==

#### 2.1 TCP 协议的作用
互联网是由一整套协议构成,`TCP 协议`只是其中的一员, 是`传输层`协议.

![](media/15622097530660/15622304810929.png)

`TCP 协议` 是`以太网协议` 和 `IP 协议` 的上层协议, 也是`应用层协议`的下层协议.

最底层的`以太网协议 Ethernet` 规定了电子信号的分组,就是如何组成成`数据包`, 解决了子网内部的点对点通信. 如下图:

![](media/15622097530660/15622305736372.jpg)

但是,`以太网协议` 不能解决多个`局域网`如何互通, 这由` IP 协议`解决. 通过` IP 协议` 可以连接多个局域网. 如下图 :

![](media/15622097530660/15622306758525.png)

`IP协议`定义了一套自己的地址规则, 叫做` IP 地址`, 它实现了`路由功能`, 允许某个局域网 A 主机向另一个局域网 B 主机发送消息.

路由器就是基于` IP协议`. 局域网之间要靠`路由器`连接.

==*IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。*==

==**<<简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包>>**==

#### 2.2 TCP 数据包的大小
==*`TCP 数据包` 在` IP 数据包`的负载里(也就是 data), `IP 数据包` 在`以太网数据包`的负载里.*==

`以太网协议数据包` 的大小是固定的.最初是 1518 字节,后来扩充到 1522 字节, 其中 1500 字节是负载(也就是 data),22 字节是头信息. `IP数据包` 在`以太网数据包` 的负载里边, 他有自己的头信息, 最少需要 20 字节. 所以` IP数据包`的负载最大是 1480 字节.

![](media/15622097530660/15622453447022.jpg)

`TCP 数据包` 在 `IP数据包`的负载里, 它的头信息最少需要 20 字节,所以` TCP 数据包` 的最大负载为 1480-20=1460 字节. 由于` IP`和` TCP`协议往往有额外的头信息, 所以==**`TCP 数据包`的负载实际为 1400 字节左右. 

![](media/15622097530660/15622455522924.jpg)

#### 2.3 TCP 数据包的编号(SEQ)
一个包 1400 字节,那么一次性发送大量数据, 就必须分成多个包. 比如,一个 10M 的文件,需要发送 7100 多个包. 发送的时候, `TCP 协议` 为每个包编号(sequence number, 简称 SEQ), 以便接收的一方按照顺序还原. 万一发生丢包, 也可以知道丢的是哪一个包.

==*第一个包的编号是一个随机数*==. 为了便于理解, 这里就把它称为 1 号包. 假定这个包的负载长度是 100 字节, 那么可以推算出下一个包的编号应该是 101(`第一个包的编号加上此包的负载,就是下个包的编号`).也就是说,每个数据包都可以得到两个编号 : `自身的编号` 和 `下个包的编号`. 接收方由此知道应该按照什么顺序将他们还原成原始文件.

举个例子 :

![](media/15622097530660/15622460205573.jpg)

当前包的编号是 45943, 下个包的编号是 46183, 由此可以,这个包的负载是 240 字节.

#### 2.4 TCP 数据包的组装.
收到` TCP 数据包` 后, 组装还原数据是操作系统完成的. 应用程序不需要直接处理 `TCP 数据包`. 对于应用程序来说, 不用关心数据通信的细节. 除非线程异常,收到的总是完整的数据. 应用程序需要的数据放在` TCP 数据包`内,有自己的格式(比如` HTTP 协议`).

`TCP 协议` 没有提供任何机制来表示原始文件的大小.这是由`应用层` 的协议来决定的. 比如` HTTP 协议`就有一个有信息 ` Content-length`来表示信息体的大小. 对与操作系统来说,就是持续的接收` TCP 数据包`, 将他们一个包都不少的按顺序组装好.

操作系统不会去处理` TCP 数据包`里边的数据. 一旦组装好` TCP 数据包`, 就把他们转交给应用程序. `TCP 数据包`里边有一个`端口 port`参数,就是用来指定转交给`监听该端口的应用程序`.

如下图 : 

![](media/15622097530660/15622467619593.jpg)

系统根据` TCP 数据包`里边的端口, 将组装好的数据转交给相应的应用程序. 上图中,21 端口是 FTP 服务器. 25 端口是 SMTP 服务器, 80 端口是 web 服务器.

应用程序接收到组装好的原始数据, 以浏览器为例, 就会根据 `HTTP 协议` 的 `Content-length` 字段正确读出一段段的数据. 这也意味着, ` 一次 TCP 通信可以包含多个 HTTP 通信`

#### 2.5 慢启动和 ACK
服务器发送数据报, 当然是越快越好, 最好是一次性全部发送出去. 但是发送的太快, 就有可能丢包. 带宽小, 路由器过热, 缓存溢出等原因都有可能导致丢包. 线路不好的话, 发的越快,丢的越多.

最理想的状态是`在线路允许的情况下, 达到最高效率.` 但是我们怎么知道对方线路的理想效率是多少呢? 答案就是 `特么的慢慢试`!!!!

==*`TCP 协议`为了作为效率和可靠性统一, 设计了一个`慢启动机制(slow start)`. 开始的时候,发送得较慢, 然后根据丢包的情况,调整速率 : 如果不丢包, 就加快发送速度; 如果丢包, 就降低发送速度.*==

Linux 内核里边设定了常量 `TCP_INIT_CWND` , 刚开始通信的时候, 向对方发送 10 个数据包, 即`发送窗口`的大小是 10, 然后停下来等待对方的确认, 然后再继续发. 默认情况下, 接收方每收到 2 个包就会发送一个确认的信息`acknowledgement`, 所以这个确认信息就简称` ACK`.

==*`ACK` 携带两个信息*== :
1. 期待要收到下一个数据包的编号.
2. 接收方的接收窗口的剩余容量.

发送发接收到接收方发送的` ACK`后, 拿到这两信息后,再加上自己已经发送的数据包的最新编号,就可以大概的推测出接收方的接收速度,从而提高或者降低发送速率. 这被称为 `发送窗口`. 这个窗口的大小是可变的.

如下图 : 

![](media/15622097530660/15622477094160.jpg)

每个` ACK` 都带有下一个数据包的编号, 以及`接收窗口`的剩余容量. 双方都会发送` ACK`.

==**注意: 由于` TCP 协议` 是双向协议, 所以双方都需要发送` ACK`, 两方的窗口大小, 很有可能不一样. 而且` ACK`只是简单的几个字段, 通常与数据合并在一个数据包里边发送.

如下图 :

![](media/15622097530660/15622478154508.jpg)

上图发生了 4 此数据通信, 第一次通信是 A 给 B 发送数据包编号是 1, 长度是 100 字节, 因此, 第二次通信 B 的` ACK`的数据包编号是 101, 第三次通信 A 的数据编号也是 101. 同理,第二次通信 B 给 A 发送的数据包编号是 1, 长度是 200, 因此第三次数据通信 A 的 ACK 的数据包编号是 201, 第四次通信 B 的数据包编号也是 201.

==**即使对于带宽很大, 线路很好的连接, `TCP 协议`也总是从 10 个数据包开始慢慢试, 过一段时间后, 才达到最高传输效率. 这就是` TCP 协议的慢启动`**==.

#### 2.6 TCP 数据包遗失处理
`TCP 协议`可以保证数据的高可靠性,保证数据的完整性, 这是怎么做到的?

前面说过,==**`ACK` 中会带有下一个数据包的编号. 如果下一个数据包没有收到,那么` ACK`的数据包编号就不会发生变化.**==

举个例子 : 如果收到了 4 号包,但是没有收到 5 号包, 那么` ACK`就会记录,期待收到 5 号包,过了一段时间,5 号包收到了,那么` ACK`就会更新期待下一个数据包的编号. 如果 5 号包还是没有收到,但是收到了 6 号包,7 号包,那么` ACK`里边的期待下一个数据包的编号不会发生变化,总是显示 5 号包,这会导致大量重复内容的` ACK`. 如果发送发发现收到 3 个重复的` ACK`, 或者超时了还是没有收到` ACK`, 就会确认丢包,即 5 号包丢失,那么就会再次发送 5 号包. 通过这种机制, `TCP 协议`保证了不会丢失数据包.

如下图 : 

![](media/15622097530660/15622483453564.jpg)

#### 2.7 TCP 协议的三次握手
==TCP 协议通过三次握手建立连接, 通讯完成时要拆除连接==
在了解三次握手之前,需要知道` TCP 报文的格式`. 如下图 : 

![](media/15622097530660/15623013409107.png)

上图中有几个比较重要的字段 : 

1. ==序号== : `Seq`, 占 32 位,用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. ==确认序号== : `ack`, 占 32 位. 只有 `ACK`标志位为 1 时, 确认序号才有效.
3. ==标志位== : 共 6 个
    1. URG : 紧急指针有效
    2. ACK : 确认序号有效.
    3. PSH : 接收方应该尽快将这个报文交给应用层
    4. RST : 重置连接
    5. SYN : 发起一个新连接
    6. FIN : 释放一个连接.



所谓`三次握手` 就是指在建立` TCP 连接`时, 需要客户端和服务端总共发送 3 个包以确认连接的建立.

**如下图:**

![](media/15622097530660/15622487084022.png)

1. 第一次握手 : Client 将标志位` SYN` 设置为 1. 随机产生一个值`seq=J`, 并将该数据报发送给 `Server`, `Client`进入` SYN_SENT`状态, 等待` Server`确认.
2. 第二次握手 : `Server` 接收到数据报后,由标志` SYN=1`知道` Client` 请求建立连接, `Server` 将标志` SYN` 和 `ACK` 都设置为 1, `ack=j+1`, 随机产生一个值` seq=K`,并将该数据包发送给` Client`以确认连接请求, `Server` 进入 `SYN_RCVD` 状态.
3. 第三次握手 : `Client` 接收到确认后, 检查` ACK` 是否为 1, `ack是否是 j+1`, 如果正确就将标志位` ACK 设置为 1`, `ack=K+1`, 并将数据包发送给` Server`, `Server`检查` ack是否为 K+1, ACK 是否为 1`, 如果正确,则连接建立成功, CLient 和 Server 进入` ESTABLIHED`状态. 完成三次握手, 随后 Client 和 Server 之间就可以开始传输数据了.

**下图是三次握手的动画**:

![](media/15622097530660/15622523889543.gif)

#### 2.8 TCP 协议的四次挥手
`四次挥手` 就是终止 `TCP连接` 连接,`指断开一个TCP 连接时, 需要客户端和服务端总共发 4 个包以确认断开连接.`

**流程图如下**:

![](media/15622097530660/15623005293196.png)


由于`TCP 连接` 是双向的,所以每个方向都需要单独进行关闭. ==*这一原则是当一方完成数据发送任务后,会发送一个` FIN`来终止连接,收到一个 FIN 意味着这个方向上没有数据流动了,即不会再接收到数据了,但是这个` TCP连接` 上仍然可以发送数据,知道这一方也发送了 `FIN`. 首先进行关闭的一方执行主动关闭, 另一方执行被动关闭.*==

1. 第一次挥手: CLient 发送一个` FIN`给 Server,用来关闭 Client 到 Server 的数据传送,Client 进入` FIN_WAIT_1`状态.
2. 第二次回收 : Server 收到` FIN`后,发送一个` ACK`给 Client,确认序号为收到序号+1,Server 进入` CLOSE_WAIT`状态.
3. 第三次挥手 : Server 发送一个` FIN` 给 CLient,用来关闭 Server 到 Client 的数据传送, Server进入` LAST_ACK`状态.
4. 第四次挥手 : CLient 收到 `FIN`后,CLient 进入` TIME_WAIT`状态, 记着发送一个` ACK`给 Server, 确认序号是接收序号+1. Server 进入` CLOSED`状态.完成四次回收.

以上过程是主动关闭和被动关闭.

实际中还会出现同时关闭的情况,具体流程如下图 :

![](media/15622097530660/15623011443311.png)


### 3. TCP 协议实现
#### 3.1 CS 模型
==TCP/IP 协议中, 两个进程间通信的主要模式为: CS 模型==.

==为啥要有 CS 模型==
- 主要目的: 协同网络中的计算机资源, 服务模式, 进程间数据共享.
- 比如: 一个网站为啥要发布在服务器上? 做好一个网站, 肯定不可能给全世界的每一个人都发送一份, 网站有更新了也不可能给每一个人推送一个信息让他们去看更新. 而是发布在服务器上, 然后想看的人就通过== CS模型== 来服务器上看网站.




## 第三章. HTTP 协议
### 1. HTTP 协议简介
  `HTTP 协议` 全称 超文本传输协议. ==是客户端浏览器或其他应用程序与服务器之间的应用层协议==. 是互联网上应用最为广泛的一种网络协议. 所有的 `WWW` 文件都必须遵循这个标准. 设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法.

对于移动端即时通讯, 尤其是 `IM 应用`, 现今主流的数据通信总结下来无外乎就是 ==**长连接+短连接**== 的方式, 而==短连接在应用上来讲就是这里要讲的 HTTP 协议的应用==.

==**所以,HTTP 是短连接. HTTP1.1 后默认是长连接, 如果有` Connection:keep-alive` 参数的话,就是会保持 TCP 连接.下面会详细的将**==.


![](media/15622134224916/15622137943430.jpg)

### 2 HTTP 请求流程和工作过程
#### 2.1 HTTP 请求流程
先参考 `TCP/IP 协议`通讯传输流程.(TCP/IP 1.4)

![](media/15622134224916/15622186771186.png)

#### 2.2 HTTP 工作工程
**HTTP 请求响应模型** :

![](media/15622134224916/15622187812074.jpg)

**HTTP 通信机制在一次完整的 HTTP 通信过程中,客户端与服务器之间将要完成以下 7 个步骤 :**
1. ==**建立 TCP 连接**== : 在 HTTP 工作开始之前,客户端首先通过网络与服务器建立连接,该连接是通过 `TCP 协议`来完成的, 该协议与 `IP 协议` 共同构建 Internet,即著名的 `TCP/IP 协议栈`, 因此 Internet 又被称做是 `TCP/IP网络`. ==`HTTP 协议` 是比 `TCP 协议` 更高层次的 应用层协议==, 根据规则, 只有==底层协议建立之后,才能进行高层协议的连接==. 因此,需要首先建立 `TCP`连接,一般` TCP`连接的端口号是==**80**==.
2. ==**客户端向服务器发送请求命令**== : 一旦建立` TCP`连接后, 客户端就会向服务器发送请求命令. 例如`GET/sample/hello.jsp HTTP/1.1`.
3. ==**客户端发送请求头信息**== : 客户端发送请求命令后, 还要以头信息的形式向服务器发送一些别的信息, ==**之后客户端发送一空白行来通知服务器,它已经结束了该头信息的发送**==.
4. ==**服务器应答**== : 客户端向服务器发出请求后, 服务器会向客户端返回响应.例如 `HTTP/1.1 200 OK`. 响应的第一部分是==协议的版本号==和响应状态码
5. ==**服务器返回响应头信息**== : 和客户端会随同请求发送关于自身的信息一样, 服务器也会随同响应向客户端发送关于自身的数据及被请求的文档;
6. ==**服务器向客户端发送数据**== : 服务器向客户端发送头信息后, 他会发送一个==空白行来标识头信息的发送到此结束==. 接着, 它就以 `Content-type` 响应头信息所描述的格式向客户发送客户所请求的实际数据.
7. ==**服务器关闭 TCP 连接**== : 一般情况下, 一旦服务器向客户端返回了请求数据, 它就要关闭 TCP 连接,==然后如果客户端或者服务器在其头信息加入了这行代码 `Connection:keep-alive`, TCP 连接在发送后将仍然保持连接状态==, 于是,客户端可以继续通过相同的连接发送请求. 保持连接节省了为每个请求建立新连接所需要的时间,还节约了网络带宽.

### 3. HTTP 基础
#### 3.1 通过请求和响应的交换达成通信
应用 `HTTP 协议` 时, 必须是一端担任客户端角色,另一端担任服务器端角色. 仅从一条通信线路来说, 服务器端和客户端的角色是确定的. ==**`HTTP 协议` 规定, 请求从客户端发出, 最后服务器端响应请求并发回**==. 换句话说, 可定是从客户端建立通信的, 服务器端在没有收到请求之前不会发送响应.

#### 3.2 HTTP 协议是不保存状态的协议
 `HTTP 协议` 是一种==无状态的协议,协议自身不对请求和响应的状态进行保存==. 也就是说在 `HTTP 协议` 这个级别, 协议对于发送过的请求或响应不作持久化,这是为了更快的处理大量事物. 确保协议的可伸展性,所以把` HTTP 协议` 设计的比较简单.

 但是随着 WEB 的不断发展,我们的很多业务都需要对通信状态进行保存,所以引入了 `cookie` 技术, 有可 `Cookie` 再用 `HTTP 协议`通信,就可以管理状态了.

#### 3.3 使用 Cookie 的状态管理
`Cookie` 是通过在请求和响应报文中写入` Cookie 信息`来控制客户端的状态.

==`Cookie` 会根据从服务器端发送的响应报文中的一个叫做 `set-cookie` 的首部字段信息,通知客户端保存` Cookie`. 当下次客户端再往服务器端发送请求的时候,会再请求报文中加入这个` Cookie 值`,然后发送出去,服务器端接收到请求后,发现` Cookie 值`, 会去检查请求是从哪一个客户端发送的,对比服务器上的记录, 最后得到之前的状态信息.==

**Cookie 的流程图** : 

![](media/15622134224916/15622213978370.jpg)

#### 3.4 请求 URL 定位资源
HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到

#### 3.5 告知服务器意图的 HTTP 方法(HTTP/1.1)
![](media/15622134224916/15622214895727.png)

#### 3.6 持久连接
在 `HTTP/1.1` 版本之前,没进行一个 HTTP 通信就要断开一次 `TCP` 连接. 这样每次请求都会造成无畏的` TCP `连接的建立和断开, 增加系统的开销.

为了解决上述为题, 在 `HTTP/1.1`版本的事实, 通过 `Connection:keep-alive` 来保持` TCP`长连接. 就是只要任意一端没有明确的提出断开连接, 则保持` TCP 连接状态`. 旨在建立一次` TCP 连接`后进行多次请求和响应的交互. ==**在` HTTP/1.1`, 所有的连接默认都是长连接.**==

#### 3.7 管线化
持久连接使得多数请求以管线化方式发送成为可能.

==以前发送一个请求后需要等待并接收响应后才能发起下一个请求, 管线化技术出现后,可以不用等待就可以发起下一个请求. 这样就能做到同时并行发送多个请求, 不需要一个接一个的等待响应了.==

### 4 与 HTTP 协议协作的 Web 服务器
HTTP 通信时,除了客户端和服务器端之后,还有一些协助通信的应用程序, 比如 `代理`, `网关`, `缓存`, `隧道`等.

#### 4.1 代理
![](media/15622134224916/15622223550019.jpg)

HTTP代理服务器是 ==Web 安全, 应用集成以及性能优化==的重要组件.

代理位于客户端和服务器之间, 接收客户端所有的 HTTP 请求, 并将这些请求转发给服务器(可能会对请求进行修改后再进行转发). 对用户来说, 这些应用程序就是一个代理,代表用户访问服务器.

出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。

#### 4.2 缓存
**浏览器一次请求流程图** : 

![-w308](media/15622134224916/15622224892176.png)

**浏览器再次请求** : 

![](media/15622134224916/15622225219526.png)

Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器, 可以将经过代理传输的常用的文档或者资源复制保存起来,下一个请求相同文档或则资源的客户端就可以直接从缓存中获取. 客户端从附近的缓存获取资源要比从远程服务器获取快的多.

#### 4.3 网关
![](media/15622134224916/15622226287995.png)

网关是一中特殊的服务器,作为其他服务器中的中间实体使用. 通常用于将 `HTTP 流量` 转换成其他的协议. 

网关接收请求时就好像自己是资源的源服务器一样. 客户端可能并不知道自己是在跟一个网关进行通信.

#### 4.4 隧道
![](media/15622134224916/15622227499271.png)

隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。

HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。


### 5 HTTP 的长连接和短连接
==**长连接**== : 指在一个连接上,可以发送多个数据报,在连接保持期间,如果没有数据报发送,需要双方发送==链路检测包==.

==**短连接**== : 指通讯双方有数据交互时, 建立一个连接,数据发送完毕后,就断开此连接. 即每次连接只完成一个业务的发送.

==长连接多用于操作频繁,点对点的通讯, 而且连接数不能太多的情况.== 每个 TCP 连接都需要三次握手,这需要时间,如果每个操作都是短连接,在操作的话处理速度就会很慢, 所以每次操作完后不断开,再次处理只要发送数据报就 OK 了, 不用建立 TCP 连接. 比如数据库的连接用长连接,如果用短连接频繁的通信会造成 socket 错误, 而且频繁的 socket 创建也是对资源的浪费

==像 WEB 网站的 HTTP 请求(`HTTP 协议`)服务一般用短连接.== 因为长连接对于服务端来说会消耗一定的资源,如果用长连接,在大数据量请求的情况下,每个用户都占用一个连接,那么对于系统的开销会很大. 所以在并发量大的时候,使用短连接好.

## 第四章 UDP 协议

==信息汇总==
- `UDP` 是面向无连接的通讯协议.
- `UDP`的数据包括 ==目的端口号(终点)==和==源端口号(起点)==
- ==用户数据协议, 非连接协议.==就是发起和接收都不需要连接, 只需要在对应端口上进行监听即可.所以可以实现==广播发送==, 并不局限于端到端.(==**TCP 是端到端, 这是 TCP 和 UDP 的最大区别**==)
- `UDP` 只管发送信息, 不管目标收没收到.
- UDP 发送的数据包有 64KB, 里边包含了发送源的端口, 所以当一个A 想 B 监听的端口发送消息后, B 可以从数据包中获取 A 的端口, 然后想 A 回送消息, 至于 A 能不能收到信息, 就看 A 有没有监听这个端口了


==为什么说 UDP 不可靠==
- 它一旦把应用程序发给网络层的数据发送出去后, 就不保留数据备份.(在 UDP 的数据层面,UDP 只管发送或者接收数据, 而不对数据做备份, 重发等等)
- UDP 在 ip 数据包的头部仅仅加入了复用和数据校验()
- 数据的发送或者接收不是靠连接的,而是通过发送端产生数据, 接收端从网络中抓取数据.
- 缺点 : 结构简单, 无校验, 速度快, 容易丢包
- 优点: 可以==**广播**==

==UDP 可以做什么==
- DNS(DNS 解析实际就是通过 UDP来做的), TFTP(文件传输协议), SNMP
- 视频,音频, 普通数据(无关紧要的数据,因为 UDP 不对数据做备份等操作)
- 单播, 多播, 广播


### 4.1 UDP 核心 API
==核心API==
- `DatagramSocket` : 接收和发送 UDP
- `DatagramPacket` : 用于处理报文

#### 1. ==DatagramSocket==
1. 最重要的一个类, 用于接收和发送 UDP.
2. 负责发送某一个 UDP 包, 或者接收 UDP 包.不需要监听某一个客户端.
3. 不同于 TCP, UDP 并没有合并到 SocketAPI 中, 所以 DatagramSocket 既是客户端又是服务端.

```java
方法:  
new DatagramSocket() : 创建简单实例, 不指定端口和 IP
new DatagramSocket(int port) : 创建监听固定端口(这里的端口指的是接收数据的客户端的端口)的实例.
new DatagramSocket(int port, InetAddress localAddr) : 创建固定端口指定 IP 的实例.
receive(DatagramPacket d) : 接收. DatagramPacket是 UDP 报文的封装类.
send(DatagramPacket d) : 发送
setSoTimeout(int timeout) : 设置超时时间. 毫秒
close() : 关闭, 释放资源
```
#### ==DatagramPacket==
1. 用于处理报文
2. 将 byte 数组(最大为 6553507), 目标地址, 目标端口等数据==包装==成报文或者将报文==拆卸==成 byte 数组.
3. 是 UDP 的发送实体, 也是接收实体. 就是发送的时候发送的是DatagramPacket对象,接收的时候也是DatagramPacket对象.
4. 构造函数中指定的 address 和 port 只有发送的时候有效.

```java
new DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) 
    byte[] buf : 要发送的 byte 数组
    int offset 和 int length: 指定发送的 byte 数组可用区间
    address 和 port : 指定接收者的地址和端口
    
new DatagramPacket(byte[] buf, int offset, int length, SocketAddress socketAddress) 
    byte[] buf : 要发送的 byte 数组
    int offset 和 int length: 指定发送的 byte 数组可用区间
    socketAddress : 相当于 InetAddress + port

setData(byte[] buf, int offset, int length) : 设置 byte数组, 并指定这个数组的有效区间
setData(byte[] byf) : 设置byte 数组, 不指定区间
setLength(int length) : 设置区间
getData() : 获取 byte[]
getOffset() : 获取 byte[] 有效区间的开始
getLength() : 获取 byte[] 的长度
setAddress(InetAddress iaddr) : 设置目标地址(设置的目标地址只有在发送的时候有效,接收的时候是无效的)
setPort(int port) : 设置目标端口(设置的目标端口只有在发送的时候有效,接收的时候是无效的)
getAddress(), getPort()
setSocketAddress(SocketAddress address) : 设置 address
getSocketAddress() : 获取 address
```

### 4.2 UDP 单播, 广播, 多播
- ==**单播**== : 就是点对点. 电脑 A 和电脑 B 之间进行数据交互, 其他电脑不会感知到这个过程, 就是单播
- ==**广播**== : 给所有的设备都发送消息.(比如大叫一声, 周围所有人都能听到, 但是你其实只是想让周围的个别人听到, 所以就有了下边的==多播==)
- ==**多播(组播)**== : 就是发送者对应多个接收者.就是一个发送者给一组接收者发送消息. 指定的这一组外的其他点感知不到. 比如有 10 个点, 5 个绿色, 5 个黄色的, 一组就代表的是所有绿色的或者是所有黄色的.也就是说多播 一组和多个意思是不一样的, 你品, 你细品!

==**广播地址运算**==

==**UDP消息发送原理**==
计算机 A 向计算机 B 发送一个消息, B 并不是一定能收到. 需要遵循一定的守则才行: B 计算机需要监听一个端口, 所有到达这个端口的 UDP 信息B 计算机就能处理. 那么 A计算想 B 计算机的 2000 端口发送消息, B 计算就能收到这条消息.

### 代码演示
#### UDP 接收消息并回送消息


#### UDP 局域网广播发送实现


#### UDP 局域网回送消息实现