# 1. 操作系统内核 kernel

## 1. Kernel 简介

开发的程序, 是放在磁盘中的, 然后需要加载到内存后, 才能执行. 

在启动计算机后, 内存中被加载的第一个程序是 `kernel`, 也就是 ==**操作系统内核**==. 内核是对硬件的资源的调度.

内核加载内内存后, 会注册一个 `GDT`, 叫做 全局描述附表, 会把内存所在的内存空间划分出来, 叫做 ==**内核空间**==, 其他的普通应用的空间, 用作 ==**用户空间**==. 

内核空间是无法被用户被直接访问的. 也就是说, ==**程序是无法直接访问内核内的数据的.也就是无法直接访问硬件.**==



### 1. kernel, 硬件,  syscall, app, 中断

Kernel 是控制硬件的, 那么此时, 一个硬件内, 比如硬盘, 或者网卡内有一个数据, 如果程序(app)想读取这个数据, 应该怎么办?

由于程序无法直接访问内核内的, 也就是无法直接访问硬盘, 或者网卡, 或者其他硬件的. 能直接访问硬件的是 kernel.  

那么就需要通过 kernel 来访问硬件, 但是程序又无法直接访问内核. 所以内核提供一个 `syscall`, 暴露了一系列的方法, 这些方法可以用来读取 kernel 内的数据. 但是又因为 APP 无法直接访问 kernel, 所以就出现一个叫做 ==**中断**==的东西.

中断作用在 CPU 上, 



### 2. 成本

经过上一小节的论述, 可以得出一个结论: 

==**成本: 如果一个程序想要访问 IO, 那么中间一定要调内核.**==

也就是说在程序调用 IO 的过程中, 会有一部分的浪费的情况.





### 3. 服务端

一个程序, 如果想做为服务端, 那么一定要==**首先开启监听状态**==, 那么对应 kernel 需要经过以下几个步骤:

1. 调用 `socket`系统调用,得到一个文件描述符, 比如 fd5, 代表这个 socket
2. bind: 绑定端口号
3. listen : 将fd5打成监听状态.
4. 调用 `accept`, 接收 fd5, 看有没有人连接进来.

在以上步骤, listen 后, 调用 `accept` 后, 这个客户端可以现在连, 也可以等一会再连. 那么此时 accept 会进入==**阻塞状态.**== 有一个客户端连进来后,会得到一个文件描述符, 比如 fd6.

加入此时还有一个客户端也想连接进来, 

